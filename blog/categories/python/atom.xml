<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Ajia's Blog]]></title>
  <link href="http://ajia.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://ajia.github.com/"/>
  <updated>2014-08-23T11:28:57+08:00</updated>
  <id>http://ajia.github.com/</id>
  <author>
    <name><![CDATA[Ajia]]></name>
    <email><![CDATA[DerekLunt@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[python笔记-内置数据类型]]></title>
    <link href="http://ajia.github.com/blog/2014/07/08/pythonxue-xi-bi-ji/"/>
    <updated>2014-07-08T09:56:00+08:00</updated>
    <id>http://ajia.github.com/blog/2014/07/08/pythonxue-xi-bi-ji</id>
    <content type="html"><![CDATA[<!--more-->


<h1>Dictionary</h1>

<p>```python</p>

<pre><code>#定义Dictionary
#方法1
d = {"server":"mpilgrim", "database":"master"} 
#方法2
fdict = dict((['x', 1], ['y', 2]))
#方法3 
#从Python 2.3 版本起, 可以用一个很方便的内建方法fromkeys() 来创建一个"默认"字典, 字典中元素具有相同的值 (如果没有给出， 默认为None):
ddict = {}.fromkeys(('x', 'y'), -1)
#------------------------------------------------------
#通过key来引用值  print d["server"] -&gt; 'mpilgrim' print d["database"] -&gt; 'master' print d["mpilgrim"] -&gt; Traceback (innermost last):
#------------------------------------------------------
#修改Dictionary
#在一个 dictionary中不能有重复的key。给一个存在的key赋值会覆盖原有的值。
d["database"] = "pubs"
print d["database"] -&gt; 'pubs'
d["uid"] = "sa"
print d["uid"] -&gt; 'sa'
#------------------------------------------------------
#判断是否存在key
'server' in dict2 # 或 
dict2.has_key('server')
#------------------------------------------------------
#删除字典元素和字典
del dict2['name'] # 删除键为“name”的条目
dict2.clear() # 删除dict2 中所有的条目
del dict2 # 删除整个dict2 字典
dict2.pop('name') # 删除并返回键为“name”的条目
#------------------------------------------------------
#获取所有key、value
dict2 = {'name': 'earth', 'port': 80}
dict2.keys() -&gt; ['port', 'name']
dict2.values() -&gt; [80, 'earth']
dict2.items() -&gt; [('port', 80), ('name', 'earth')]
#------------------------------------------------------
#排序
#按照value的值从大到小的顺序来排序
dic = {'a':31, 'bc':5, 'c':3, 'asd':4, 'aa':74, 'd':0}
dict= sorted(dic.iteritems(), key=lambda d:d[1], reverse = True)
print dict
#对字典按键（key）排序
dic = {'a':31, 'bc':5, 'c':3, 'asd':4, 'aa':74, 'd':0}
dict= sorted(dic.iteritems(), key=lambda d:d[0])  #d[0]表示字典的键
print dict
</code></pre>

<p>```</p>

<h1>List</h1>

<p>```python</p>

<pre><code>#定义List
&gt;&gt;&gt;li = ["a", "b", "mpilgrim", "z", "example"]
&gt;&gt;&gt;li
["a", "b", "mpilgrim", "z", "example"]
&gt;&gt;&gt;li[0]
'a'
&gt;&gt;&gt;li[4]
'example'
&gt;&gt;&gt;li[-1] #li[-n] = li[len[li]-n]
'example'
&gt;&gt;&gt;li[-3]
'mpilgrim'
#添加元素
&gt;&gt;&gt;li.append("cc")
&gt;&gt;&gt; li
['a', 'b', 'mpilgrim', 'z', 'example', 'cc']
#合并列表
&gt;&gt;&gt; li.extend([1,2,3,4])
&gt;&gt;&gt; li
['a', 'b', 'mpilgrim', 'z', 'example', 'cc', 1, 2, 3, 4]
#删除元素
&gt;&gt;&gt; del li[0]
&gt;&gt;&gt; li
['b', 'mpilgrim', 'z', 'example', 'cc', 1, 2, 3, 4]
#分片(slice)
&gt;&gt;&gt;li[1:3]
["b", "mpilgrim"]
&gt;&gt;&gt; li.remove('b')
&gt;&gt;&gt; li
['mpilgrim', 'z', 'example', 'cc', 1, 2, 3, 4]
#多列排序
&gt;&gt;&gt;list = [{"name":"aa", "sort":1}, {"name":"bb", "sort":8}, {"name":"zz", "sort":5}, {"name":"ff", "sort":3}]
&gt;&gt;&gt;from operator import itemgetter, attrgetter
&gt;&gt;&gt;list.sort(key=itemgetter("sort", "name"), reverse=True)
&gt;&gt;&gt;list
[{'sort': 8, 'name': 'bb'}, {'sort': 5, 'name': 'zz'}, {'sort': 3, 'name': 'ff'}, {'sort': 1, 'name': 'aa'}]
</code></pre>

<p>```</p>

<h1>Tuple</h1>

<p>tuple是不可变的list, 一旦创建了一个tuple，就不能以任何方式改变它。tuple没有方法，使用tuple的好处：</p>

<ul>
<li>tuple比list操作速度快；</li>
<li>对不需要修改的数据进行“写保护”，使代码更安全；</li>
<li>tuple可以在dictionary中被用做key，但是list不行。</li>
</ul>


<p>```python</p>

<h1>定义tuple</h1>

<blockquote><blockquote><blockquote><p>t = ("a", "b", "mpilgrim", "z", "example")
t
("a", "b", "mpilgrim", "z", "example")
t[0]
'a'
t[-1]
'example'
t[1:3]
('b', 'mpilgrim')
```</p></blockquote></blockquote></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决json.dumps不能序列化datetime类型的问题]]></title>
    <link href="http://ajia.github.com/blog/2014/03/20/pythonzhong-zhuan-hua-cheng-jsonde-fang-fa-bu-neng-xu-lie-hua-datetimelei-xing-shu-ju-de-wen-ti/"/>
    <updated>2014-03-20T14:01:00+08:00</updated>
    <id>http://ajia.github.com/blog/2014/03/20/pythonzhong-zhuan-hua-cheng-jsonde-fang-fa-bu-neng-xu-lie-hua-datetimelei-xing-shu-ju-de-wen-ti</id>
    <content type="html"><![CDATA[<!-- more -->


<p>使用python自带的json.</p>

<p>dumps方法转换数据为json的时候，如果格式化的数据中有datetime类型的数据时会报错</p>

<pre><code>TypeError: datetime.datetime(2014, 03, 20, 12, 10, 44) is not JSON serializable
</code></pre>

<p>查了一下，找到如下的方法:</p>

<p>```python
  import json
  from datetime import date, datetime
  class MyEncoder(json.JSONEncoder):</p>

<pre><code>def default(self, obj):
    # if isinstance(obj, datetime.datetime):
    #     return int(mktime(obj.timetuple()))
    if isinstance(obj, datetime):
        return obj.strftime('%Y-%m-%d %H:%M:%S')
    elif isinstance(obj, date):
        return obj.strftime('%Y-%m-%d')
    else:
        return json.JSONEncoder.default(self, obj)
 print json.dumps(dataMap, cls=MyEncoder)
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python的集合运算]]></title>
    <link href="http://ajia.github.com/blog/2014/03/19/pythonde-ji-he-yun-suan/"/>
    <updated>2014-03-19T16:59:00+08:00</updated>
    <id>http://ajia.github.com/blog/2014/03/19/pythonde-ji-he-yun-suan</id>
    <content type="html"><![CDATA[<!-- more -->


<p>python用来写一些提高工作效率的脚本真的非常方便，我越来越喜欢这门简单又强大的语言了。为了计算出两个list之间的交集、并集和差集，查了一下记录在下面：</p>

<h3>获取两个list的交集</h3>

<p>```python</p>

<h1>方法一:</h1>

<p>a=[2,3,4,5]
b=[2,5,8]
tmp = [val for val in a if val in b]
print tmp</p>

<h1>[2, 5]</h1>

<h1>方法二:</h1>

<p>print list(set(a).intersection(set(b)))
```</p>

<h3>获取两个list的并集</h3>

<p><code>python
print list(set(a).union(set(b)))
</code></p>

<h3>获取两个list的差集</h3>

<p><code>python
print list(set(b).difference(set(a))) # b中有而a中没有的
</code></p>
]]></content>
  </entry>
  
</feed>

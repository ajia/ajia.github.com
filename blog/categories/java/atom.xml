<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Ajia's Blog]]></title>
  <link href="http://ajia.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://ajia.github.com/"/>
  <updated>2013-05-24T11:56:21+08:00</updated>
  <id>http://ajia.github.com/</id>
  <author>
    <name><![CDATA[Ajia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[joda日期计算]]></title>
    <link href="http://ajia.github.com/blog/2013/05/24/jodari-qi-ji-suan/"/>
    <updated>2013-05-24T10:19:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/24/jodari-qi-ji-suan</id>
    <content type="html"><![CDATA[<p>Joda-Time提供了一组Java类包用于处理包括ISO8601标准在内的date和time。可以利用它把JDK Date和Calendar类完全替换掉，而且仍然能够提供很好的集成</p>

<!-- more -->


<p>获取DateTime:<br/>
<code>java
//方法一：取系统点间  
DateTime dt1 = new DateTime();  
//方法二：通过java.util.Date对象生成  
DateTime dt2 = new DateTime(new Date());  
//方法三：指定年月日点分秒生成(参数依次是：年,月,日,时,分,秒,毫秒)  
DateTime dt3 = new DateTime(2012, 5, 20, 13, 14, 0, 0);  
//方法四：ISO8601形式生成  
DateTime dt4 = new DateTime("2012-05-20");  
DateTime dt5 = new DateTime("2012-05-20T13:14:00");  
//只需要年月日的时候  
LocalDate localDate = new LocalDate(2009, 9, 6);// September 6, 2009  
//只需要时分秒毫秒的时候  
LocalTime localTime = new LocalTime(13, 30, 26, 0);// 1:30:26PM
</code></p>

<p>获取年月日点分秒<br/>
<code>java
DateTime dt = new DateTime();  
//年  
int year = dt.getYear();  
//月  
int month = dt.getMonthOfYear();  
//日  
int day = dt.getDayOfMonth();  
//星期  
int week = dt.getDayOfWeek();  
//点  
int hour = dt.getHourOfDay();  
//分  
int min = dt.getMinuteOfHour();  
//秒  
int sec = dt.getSecondOfMinute();  
//毫秒  
int msec = dt.getMillisOfSecond();
</code></p>

<p>星期的特殊处理<br/>
```java
DateTime dt = new DateTime();<br/>
//星期<br/>
switch(dt.getDayOfWeek()) {<br/>
case DateTimeConstants.SUNDAY:</p>

<pre><code>System.out.println("星期日");  
break;  
</code></pre>

<p>case DateTimeConstants.MONDAY:</p>

<pre><code>System.out.println("星期一");  
break;  
</code></pre>

<p>case DateTimeConstants.TUESDAY:</p>

<pre><code>System.out.println("星期二");  
break;  
</code></pre>

<p>case DateTimeConstants.WEDNESDAY:</p>

<pre><code>System.out.println("星期三");  
break;  
</code></pre>

<p>case DateTimeConstants.THURSDAY:</p>

<pre><code>System.out.println("星期四");  
break;  
</code></pre>

<p>case DateTimeConstants.FRIDAY:</p>

<pre><code>System.out.println("星期五");  
break;  
</code></pre>

<p>case DateTimeConstants.SATURDAY:</p>

<pre><code>System.out.println("星期六");  
break;  
</code></pre>

<p>}
```</p>

<p>与JDK日期对象转换<br/>
<code>java
DateTime dt = new DateTime();  
//转换成java.util.Date对象  
Date d1 = new Date(dt.getMillis());  
Date d2 = dt.toDate();  
//转换成java.util.Calendar对象  
Calendar c1 = Calendar.getInstance();  
c1.setTimeInMillis(dt.getMillis());  
Calendar c2 = dt.toCalendar(Locale.getDefault());
</code></p>

<p>日期前后推算<br/>
<code>java
DateTime dt = new DateTime();  
//昨天  
DateTime yesterday = dt.minusDays(1);         
//明天  
DateTime tomorrow = dt.plusDays(1);       
//1个月前  
DateTime before1month = dt.minusMonths(1);        
//3个月后  
DateTime after3month = dt.plusMonths(3);          
//2年前  
DateTime before2year = dt.minusYears(2);          
//5年后  
DateTime after5year = dt.plusYears(5);
</code></p>

<p>取特殊日期<br/>
<code>java
DateTime dt = new DateTime();     
//月末日期    
DateTime lastday = dt.dayOfMonth().withMaximumValue();  
//90天后那周的周一  
DateTime firstday = dt.plusDays(90).dayOfWeek().withMinimumValue();
</code></p>

<p>计算区间<br/>
<code>java
DateTime begin = new DateTime("2012-02-01");  
DateTime end = new DateTime("2012-05-01");  
//计算区间毫秒数  
Duration d = new Duration(begin, end);  
long time = d.getMillis();  
//计算区间天数  
Period p = new Period(begin, end, PeriodType.days());  
int days = p.getDays();  
//计算特定日期是否在该区间内  
Interval i = new Interval(begin, end);  
boolean contained = i.contains(new DateTime("2012-03-01"));
</code></p>

<p>日期比较<br/>
<code>java
DateTime d1 = new DateTime("2012-02-01");  
DateTime d2 = new DateTime("2012-05-01");  
//和系统时间比  
boolean b1 = d1.isAfterNow();  
boolean b2 = d1.isBeforeNow();  
boolean b3 = d1.isEqualNow();  
//和其他日期比  
boolean f1 = d1.isAfter(d2);  
boolean f2 = d1.isBefore(d2);  
boolean f3 = d1.isEqual(d2);
</code></p>

<p>格式化输出<br/>
<code>java
DateTime dateTime = new DateTime();  
String s1 = dateTime.toString("yyyy/MM/dd hh:mm:ss.SSSa");  
String s2 = dateTime.toString("yyyy-MM-dd HH:mm:ss");  
String s3 = dateTime.toString("EEEE dd MMMM, yyyy HH:mm:ssa");  
String s4 = dateTime.toString("yyyy/MM/dd HH:mm ZZZZ");  
String s5 = dateTime.toString("yyyy/MM/dd HH:mm Z");
</code>
时区<br/>
<code>java
//默认设置为日本时间  
DateTimeZone.setDefault(DateTimeZone.forID("Asia/Tokyo"));  
DateTime dt1 = new DateTime();  
//伦敦时间  
DateTime dt2 = new DateTime(DateTimeZone.forID("Europe/London"));
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读取音频文件的信息]]></title>
    <link href="http://ajia.github.com/blog/2013/05/06/du-qu-yin-pin-wen-jian-de-xin-xi/"/>
    <updated>2013-05-06T18:33:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/06/du-qu-yin-pin-wen-jian-de-xin-xi</id>
    <content type="html"><![CDATA[<p>项目里需要读取音频的播放时间，找了一个下午发现这个：jaudiotagger(http://www.jthink.net/jaudiotagger/)，它是一个音频标签JAVA库，目前支持 Mp3, Mp4 (Mp4 audio, M4a and M4p audio) Ogg Vorbis, Flac and Wma, 但是对Wav 和 Real 的支持有限。</p>

<!-- more -->


<p>读取m4a格式的播放时间<br/>
```java</p>

<pre><code>/**
 * 获取m4a格式文件的播放时间
 * @param filePath
 * @return
 */
public static int getMp4AudioLength (String filePath){
    File file = new File(filePath);
    Mp4FileReader reader = new Mp4FileReader();
    int length = -1;
    AudioFile f;
    try {
        f = reader.read(file);
        AudioHeader head = f.getAudioHeader();
        length = head.getTrackLength();
    } catch (CannotReadException e) {
        log.error(e.getMessage(), e);
    } catch (IOException e) {
        log.error(e.getMessage(), e);
    } catch (TagException e) {
        log.error(e.getMessage(), e);
    } catch (ReadOnlyFileException e) {
        log.error(e.getMessage(), e);
    } catch (InvalidAudioFrameException e) {
        log.error(e.getMessage(), e);
    }
    return length;
}
</code></pre>

<p>```</p>

<p>读取mp3格式的播放时间<br/>
```java</p>

<pre><code>/**
 * 获取mp3格式文件的播放时间
 * @param filePath
 * @return
 */
public static int getMp3AudioLength (String filePath){
    File file = new File(filePath);
    int length = -1;
    try {
        MP3File f = (MP3File)AudioFileIO.read(file);
        MP3AudioHeader audioHeader = f.getMP3AudioHeader();
        length = audioHeader.getTrackLength();
    } catch (CannotReadException e) {
        log.error(e.getMessage(), e);
    } catch (IOException e) {
        log.error(e.getMessage(), e);
    } catch (TagException e) {
        log.error(e.getMessage(), e);
    } catch (ReadOnlyFileException e) {
        log.error(e.getMessage(), e);
    } catch (InvalidAudioFrameException e) {
        log.error(e.getMessage(), e);
    }
    return length;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用jave转换音视频格式]]></title>
    <link href="http://ajia.github.com/blog/2013/05/04/shi-yong-javezhuan-huan-yin-shi-pin-ge-shi/"/>
    <updated>2013-05-04T15:54:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/04/shi-yong-javezhuan-huan-yin-shi-pin-ge-shi</id>
    <content type="html"><![CDATA[<p>JAVE是用java包装ffmpeg的一个类库，可以自由的在各种音视频格式之间转换，它的jar包里就包含了ffmpeg的可执行文件，有linux和windows的，我为了在本机上调试，去ffmpeg的官网下了一个Mac OSX版本的。</p>

<p>官网地址：http://www.sauronsoftware.it/projects/jave/。养成去看官网的习惯很重要，英语差点的话可以先看中文的介绍，有个概念再去看官网的说明。</p>

<!-- more -->


<p>
我是直接用源代码跑的，方便调试问题。下面是mp3转换为m4a格式的一个例子，更多的例子和请去官网查看
```java
/**</p>

<pre><code> * 转化音频格式
 * @param s
 * @param t
 * @throws IllegalArgumentException
 * @throws InputFormatException
 * @throws EncoderException
 */
private void convertAudio(String s, String t){
    File source = new File(s);
    File target = new File(t);
    AudioAttributes audio = new AudioAttributes();
    audio.setCodec("libmp3lame");
    audio.setBitRate(new Integer(128000));
    audio.setChannels(new Integer(2));
    audio.setSamplingRate(new Integer(44100));
    EncodingAttributes attrs = new EncodingAttributes();
    attrs.setFormat("mp4");
    attrs.setAudioAttributes(audio);
    Encoder encoder = new Encoder();
    try {
        encoder.encode(source, target, attrs);
    } catch (IllegalArgumentException e) {
        log.error(e.getMessage(), e);
    } catch (InputFormatException e) {
        log.error(e.getMessage(), e);
    } catch (EncoderException e) {
        log.error(e.getMessage(), e);
    }
}
</code></pre>

<p>```
转换的时候老是报错，抛出EncoderException异常，我查了一下源码，注释掉Encoder.java的864行</p>

<blockquote><blockquote><p>throw new EncoderException(line);</p></blockquote></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql创建function失败]]></title>
    <link href="http://ajia.github.com/blog/2013/04/16/mysqlchuang-jian-functionshi-bai/"/>
    <updated>2013-04-16T16:12:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/04/16/mysqlchuang-jian-functionshi-bai</id>
    <content type="html"><![CDATA[<p>出错信息：</p>

<p>创建function时</p>

<pre><code>ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL,
or READS SQL DATA in its declaration and binary logging is enabled 
(you might want to use the less safe log_bin_trust_function_creators variable)
</code></pre>

<p>原因：</p>

<p>这是我们开启了bin-log, 我们就必须指定我们的函数是否是
1 DETERMINISTIC 不确定的
2 NO SQL 没有SQl语句，当然也不会修改数据
3 READS SQL DATA 只是读取数据，当然也不会修改数据
4 MODIFIES SQL DATA 要修改数据
5 CONTAINS SQL 包含了SQL语句</p>

<p>其中在function里面，只有 DETERMINISTIC, NO SQL 和 READS SQL DATA 被支持。如果我们开启了 bin-log, 我们就必须为我们的function指定一个参数。</p>

<p>解决办法</p>

<pre><code>mysql&gt;show variables like '%func%';
+---------------------------------+-------+  
|Variable_name                  |Value|  
+---------------------------------+-------+  
|log_bin_trust_function_creators|OFF  |  
+---------------------------------+-------+  

set global log_bin_trust_function_creators=1;  

mysql&gt;show variables like '%func%';  
+---------------------------------+-------+  
|Variable_name                  |Value|  
+---------------------------------+-------+  
|log_bin_trust_function_creators|ON   |  
+---------------------------------+-------+  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hessian版本冲突的问题]]></title>
    <link href="http://ajia.github.com/blog/2013/04/11/hessianban-ben-chong-tu-de-wen-ti/"/>
    <updated>2013-04-11T17:53:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/04/11/hessianban-ben-chong-tu-de-wen-ti</id>
    <content type="html"><![CDATA[<p>项目需要调用远程的接口，用的是hessian，写了一段代码测试，结果报错
```java</p>

<pre><code>HessianProtocolException：expected integer at…
</code></pre>

<p>```</p>

<p>非常简短，让人摸不着头脑。寻找了一段时间，在网上发现这样一句话</p>

<blockquote><blockquote><p>use hessian-4.<em> spring-3.</em>  resin-4.<em>. for Hessian protocol 2.And resin-3.</em>, spring-2.* hessian before 3.2.0 for Hessian protocol version 1.</p></blockquote></blockquote>

<p>看来是版本的问题，我的环境是resin-4.*、spring-2.*、hessian-4.*，后来改成用resin.3.1.13版本就正常了。接下来试试把spring升级到3。</p>
]]></content>
  </entry>
  
</feed>

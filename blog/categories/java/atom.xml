<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Ajia's Blog]]></title>
  <link href="http://ajia.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://ajia.github.com/"/>
  <updated>2014-08-21T21:32:05+08:00</updated>
  <id>http://ajia.github.com/</id>
  <author>
    <name><![CDATA[Ajia]]></name>
    <email><![CDATA[DerekLunt@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Guava的使用指南之Cache]]></title>
    <link href="http://ajia.github.com/blog/2013/07/05/guavade-shi-yong-zhi-nan-zhi-cache/"/>
    <updated>2013-07-05T17:42:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/07/05/guavade-shi-yong-zhi-nan-zhi-cache</id>
    <content type="html"><![CDATA[<!-- more -->


<h3>创建cache</h3>

<p>可以通过两种方式来创建cache：</p>

<pre><code>cacheLoader

callable callback
</code></pre>

<p>通过这两种方法创建的cache，和通常用map来缓存的做法比，不同在于，这两种方法都实现了一种逻辑——从缓存中取key X的值，如果该值已经缓存过了，则返回缓存中的值，如果没有缓存过，可以通过某个方法来获取这个值。</p>

<p>但不同的在于cacheloader的定义比较宽泛，是针对整个cache定义的，可以认为是统一的根据key值load value的方法。</p>

<p>而callable的方式较为灵活，允许你在get的时候指定。</p>

<p>下面是两种方法的例子:</p>

<p>首先是基于cacheloader的方法</p>

<p>```java</p>

<pre><code>@Test
public void testCacheBuilder() throws ExecutionException {
    LoadingCache&lt;String, String&gt; graphs = CacheBuilder.newBuilder().maximumSize(1000)
            .build(new CacheLoader&lt;String, String&gt;() {
                public String load(String key) {
                    // 这里是key根据实际去取值的方法，例如根据这个key去数据库或者properties文件中取值
                    ApplicationContext context = new FileSystemXmlApplicationContext("E:/WorkDir/struts2practice/GuavaTest/WebRoot/WEB-INF/xml/springConfig.xml");
                    JdbcCustomerDAO aJdbcCustomerDAO = context.getBean(JdbcCustomerDAO.class);
                    System.out.println("load method has been invoked");
                    return aJdbcCustomerDAO.findValue(key);
                }
            });
    String resultVal = graphs.get("testKey");
    System.out.println("first time value is: " + resultVal);
    String resultVal1 = graphs.get("testKey");
    System.out.println("second time values is: " + resultVal1);
}
</code></pre>

<p>```</p>

<p>其次是基于实现callable的方法：</p>

<p>```java
@Test</p>

<pre><code>public void testCallable() throws ExecutionException {
    // 没有使用CacheLoader
    Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(1000).build();
    String resultVal = cache.get("testKey", new Callable&lt;String&gt;() {
        public String call() {
            // 这里先根据key实际去取值的方法，例如根据这个key去数据库或者properties文件中取值
            ApplicationContext context = new FileSystemXmlApplicationContext("E:/WorkDir/struts2practice/GuavaTest/WebRoot/WEB-INF/xml/springConfig.xml");
            JdbcCustomerDAO aJdbcCustomerDAO = context.getBean(JdbcCustomerDAO.class);
            System.out.println("resultVal call method is invoked");
            return aJdbcCustomerDAO.findValue("testKey");
        }
    });
    System.out.println("first time value is: " + resultVal);
    String resultVal1 = cache.get("testKey", new Callable&lt;String&gt;() {
        public String call() {
            // 这里先根据key实际去取值的方法，例如根据这个key去数据库或者properties文件中取值
            ApplicationContext context = new FileSystemXmlApplicationContext("E:/WorkDir/struts2practice/GuavaTest/WebRoot/WEB-INF/xml/springConfig.xml");
            JdbcCustomerDAO aJdbcCustomerDAO = context.getBean(JdbcCustomerDAO.class);
            System.out.println("resultVal1 call method is invoked");
            return aJdbcCustomerDAO.findValue("testKey");
        }
    });
    System.out.println("second time values is: " + resultVal1);
}
</code></pre>

<p>```</p>

<!-- more -->


<h3>缓存数据的移除</h3>

<h5>基于大小的移除</h5>

<p>看字面意思就知道就是按照缓存的大小来移除，如果即将到达指定的大小，那就会把不常用的键值对从cache中移除。</p>

<p>定义的方式一般为 CacheBuilder.maximumSize(long)，官方还介绍了一种可以算权重的方法，个人认为实际使用中不太用到，暂不讨论。</p>

<p>就这个常用的来看有几个注意点，</p>

<p>其一，这个size指的是cache中的条目数，不是内存大小或是其他；</p>

<p>其二，并不是完全到了指定的size系统才开始移除不常用的数据的，而是接近这个size的时候系统就会开始做移除的动作；</p>

<p>其三，如果一个键值对已经从缓存中被移除了，你再次请求访问的时候，如果cachebuild是使用cacheloader方式的，那依然还是会从cacheloader中再取一次值，如果这样还没有，就会抛出异常</p>

<h5>基于时间的移除</h5>

<p>guava提供了两个基于时间移除的方法</p>

<p>expireAfterAccess(long, TimeUnit)  这个方法是根据某个键值对最后一次访问之后多少时间后移除</p>

<p>expireAfterWrite(long, TimeUnit)   这个方法是根据某个键值对被创建或值被替换后多少时间移除</p>

<h5>基于引用的移除</h5>

<p>这种移除方式主要是基于java的垃圾回收机制，根据键或者值的引用关系决定移除，个人对垃圾回收这块不是非常了解，窃以为不太可靠。。也不常用。。所以没有研究，欢迎补充。</p>

<p>主动移除有三种方法：</p>

<p>单独移除用 Cache.invalidate(key)</p>

<p>批量移除用 Cache.invalidateAll(keys)</p>

<p>移除所有用 Cache.invalidateAll()</p>

<p>如果需要在移除数据的时候有所动作还可以定义Removal Listener，但是有点需要注意的是默认Removal Listener中的行为是和移除动作同步执行的，如果需要改成异步形式，可以考虑使用RemovalListeners.asynchronous(RemovalListener, Executor)</p>

<h3>刷新操作</h3>

<p>refresh 操作， 与evict不同， 是给key一个new value， 同时如果在refresh时有访问，那么将会返回old value， 而evict则会等待evict结束返回new value
定义refresh一般使用异步的操作</p>

<p>```java
// Some keys don't need refreshing, and we want refreshes to be done asynchronously.
LoadingCache&lt;Key, Graph> graphs = CacheBuilder.newBuilder()</p>

<pre><code>   .maximumSize(1000)
   .refreshAfterWrite(1, TimeUnit.MINUTES)
   .build(
       new CacheLoader&lt;Key, Graph&gt;() {
         public Graph load(Key key) { // no checked exception
           return getGraphFromDatabase(key);
         }
         public ListenableFuture&lt;Graph&gt; reload(final Key key, Graph prevGraph) {
           if (neverNeedsRefresh(key)) {
             return Futures.immediateFuture(prevGraph);
           } else {
             // asynchronous!
             return ListenableFutureTask.create(new Callable&lt;Graph&gt;() {
               public Graph call() {
                 return getGraphFromDatabase(key);
               }
             });
           }
         }
       });
</code></pre>

<p>```
在refreshAfterWrite方法，会调用reload</p>

<h3>统计</h3>

<p>提供了一些数据采集的方法</p>

<ul>
<li><p>CacheBuilder.recordStats() 方法启动了 cache的数据收集</p></li>
<li><p>Cache.stats() 返回了一个CacheStats对象， 提供一些数据方法</p></li>
<li><p>hitRate()， 请求点击率</p></li>
<li><p>averageLoadPenalty()， 加载new value，花费的时间， 单位nanosecondes</p></li>
<li><p>evictionCount()， 清除的个数</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guava的使用指南之Collections]]></title>
    <link href="http://ajia.github.com/blog/2013/05/31/guavade-shi-yong-zhi-nan-zhi-collections/"/>
    <updated>2013-05-31T13:45:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/31/guavade-shi-yong-zhi-nan-zhi-collections</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Guava Collections可以帮助我们写出更简短精炼、可读性强的代码。</p>

<p>看看Guava Collections为我们做了哪些很酷的事情：</p>

<ul>
<li>Immutable Collections:还在使用Collections.unmodifiableXXX()? Immutable Collections这才是真正的不可修改的集合</li>
<li>Multiset:看看如何把重复的元素放入一个集合</li>
<li>Multimaps:需要在一个key对应多个value的时候，自己写一个实现比较繁琐，让Multimaps来帮帮</li>
<li>BiMap:java.util.Map只能保证key的不重复，BiMap保证value也不重复</li>
<li>MapMaker:超级强大的Map构造类</li>
<li>Ordering class:大家知道用Comparator作为比较器来对集合排序，但是对于多关键字排序Ordering class可以简化很多的代码</li>
<li>其他特性</li>
</ul>


<p>当然，如果没有Guava Collections你也可以用Java Collections Framework完成上面的功能。但是Guava Collections提供的这些API经过精心设计，而且还有2500个单元测试来保障它的质量。所以我们没必要重新发明轮子。接下来我们来详细看看Guava Collections的一些具体功能。</p>

<h2>Immutable Collections：真正的不可修改的集合</h2>

<p>大家都用过Collections.unmodifiableXXX()来做一个不可修改的集合。例如你要构造存储常量的Set,你可以这样做：</p>

<p><code>java
Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(new String[]{"RED","GREEN"}));
Set&lt;String&gt; unmodifiableSet = Collections.unmodifiableSet(set);
</code></p>

<p>这看上去似乎不错，因为每次调unmodifiableSet.add()都会抛出一个UnsupportedOperationException。感觉安全了？慢！如果有人在原来的set上add或者remove元素会怎么样？结果unmodifiableSet也是被add或者remove元素了。而且构造这样一个简单的set写了两句长的代码。下面看看ImmutableSet是怎么来做地更安全和简洁：</p>

<p><code>java
ImmutableSet&lt;String&gt; immutableSet = ImmutableSet.of("RED","GREEN");
</code></p>

<p>就这样一句就够了，而且试图调add方法的时候，它一样会抛出UnsupportedOperationException。重要的是代码的可读性增强了不少，非常直观的展现了代码的用意。如果像之前这个代码保护一个set怎么做呢？你可以：</p>

<p><code>java
ImmutableSet&lt;String&gt; immutableSet = ImmutableSet.copyOf(set);
</code></p>

<p>从构造的方式来说，ImmutableSet集合还提供了Builder模式来构造一个集合：</p>

<p><code>java
Builder&lt;String&gt; builder = ImmutableSet.builder();
ImmutableSet&lt;String&gt; immutableSet = builder.add("RED").addAll(set).build();
</code></p>

<p>在这个例子里面Builder不但能加入单个元素还能加入既有的集合。</p>

<p>除此之外，Guava Collections还提供了各种Immutable集合的实现：ImmutableList, ImmutableMap, ImmutableSortedSet, ImmutableSortedMap。</p>

<h2>Multiset:把重复的元素放入集合</h2>

<p>你可能会说这和Set接口的契约冲突，因为Set接口的javaDoc里面规定不能放入重复元素。事实上，Multiset并没有实现java.util.Set接口，它更像是一个Bag。普通的Set就像这样：[car,ship,bike],而Multiset会是这样：[carx2,shipx6,bikex3]。</p>

<p>譬如一个List里面有各种字符，然后你要统计每个字符串在List里面出现的次数：</p>

<p>```java
Map&lt;String, Integer> map = new HashMap&lt;String, Integer>();
for(String word:wordList){</p>

<pre><code>Integer count = map.get(word);
map.put(word, (count==null)?1:count+1);
</code></pre>

<p>}
//count word "the"
Integer count = map.get("the");
```</p>

<p>如果用Multiset就可以这样：
<code>java
HashMultiset&lt;String&gt; multiSet = HashMultiset.create();
multiSet.addAll(wordList);
//count word "the"
Integer count = multiSet.count("the");
</code></p>

<p>这样连循环都不用了，而且Multiset用的方法叫count，显然比在Map里面调用get有更好的可读性。Multiset还提供了setCount这样设定元素重复次数的方法，虽然你可以通过使用Map来实现类似的功能，但是程序的可读性比Multiset差了很多。</p>

<p>常用实现Multiset接口的类有：
* HashMultiset:元素存放于HashMap
* LinkedHashMultiset:元素存放于LinkedHashMap,即元素的排列顺序由第一次放入的顺序决定
* TreeMultiset:元素被排序存放于TreeMap
* EnumMultiset:元素必须是enum类型
* ImmutableMultiset:不可修改的Mutiset</p>

<p>看到这里你可能已经发现Guava Collections都是以create或是of这样的静态方法来构造对象。这是因为这些集合类大多有多个参数的私有构造方法，由于参数数目很多，客户代码程序员使用起来就很不方便。而且以这种方式可以返回原类型的子类型对象。另外，对于创建范型对象来讲，这种方式更加简洁。</p>

<h2>Muitimap:在Map的value里面放多个元素</h2>

<p>Muitimap就是一个key对应多个value的数据结构。看上去它很像java.util.Map的结构，但是Muitimap不是Map，没有实现Map的接口。设想你对Map调了2次参数key一样的put方法，结果就是第2次的value覆盖了第一次的value。但是对Muitimap来说这个key同时对应了2个value。所以Map看上去是：{k1=v1,k2=v2,…}，而Muitimap是：{k1=[v1,v2,v3],k2=[v7,v8],…}。</p>

<p>举个记名投票的例子。所有选票都放在一个List<Ticket>里面，List的每个元素包括投票人和选举人的名字。我们可以这样写:</p>

<p>```java
//Key is cadidate name, its value is his voters
HashMap&lt;String, HashSet<String>> hMap = new HashMap&lt;String, HashSet<String>>();
for(Ticket ticket:tickets){</p>

<pre><code>HashSet&lt;String&gt; set = hMap.get(ticket.getCandidate());
if(set==null){
    set = new HashSet&lt;String&gt;();
    hMap.put(ticket.getCandidate(), set);
}
set.add(ticket.getVoter);
</code></pre>

<p>}
```</p>

<p>我们再来看看Muitimap能做些什么：</p>

<p>```java
HashMultimap&lt;String, String> map = HashMultimap.create();
for(Ticket ticket:tickets){</p>

<pre><code>map.put(ticket.getCandidate(), ticket.getVoter());
</code></pre>

<p>}
```</p>

<p>就这么简单！</p>

<p>Muitimap接口的主要实现类有：
* HashMultimap:key放在HashMap, 而value放在HashSet, 即一个key对应的value不可重复
* ArrayListMultimap：key放在HashMap,而value放在ArrayList,即一个key对应的value有顺序可重复
* LinkedHashMultimap:key放在LinkedHashMap,而value放在LinkedHashSet,即一个key对应的value有顺序不可重复
* TreeMultimap：key放在TreeMap，而value放在TreeSet，即一个key对应的value有排列顺序
* ImmutableMultimap:不可修改的Multimap</p>

<h2>BiMap:双向Map</h2>

<p>BiMap实现了java.util.Map接口。它的特点是它的value和它key一样也是不可重复的，换句话说它的key和value是等价的。如果你往BiMap的value里面放了重复的元素，就会得到IllegalArgumentException.</p>

<p>举个例子，你可能经常会碰到在Map里面根据value值来反推它的key值的逻辑：</p>

<p>```java
for(Map.Entry&lt;User, Address> entry:map.entreSet()){</p>

<pre><code>if(entry.getValue().equals(anAddress)){
    return entry.getKey();
}
</code></pre>

<p>}
```</p>

<p>如果把User和Address都放在BiMap,那么一句代码就得到结果了：</p>

<p>```java</p>

<pre><code>return biMap.inverse().get(anAddress);
</code></pre>

<p>```</p>

<p>这里的inverse方法就是把BiMap的key集合value集合对调，因此biMap==biMap.inverse().inverse()。</p>

<p>BiMap的常用实现有：
* HashBiMap:key集合与value集合都有HashMap实现
* EnumBiMap:key与value都必须是enum类型
* ImmutableBiMap:不可修改的BiMap</p>

<h2>MapMaker:超级强大的Map构造工具</h2>

<p>MapMaker是用来构造ConcurrentMap的工具类。为什么可以把MapMaker叫做超级强大？看了下面的例子你就知道了。首先，它可以用来构造ConcurrentHashMap:</p>

<p><code>java
//ConcurrentHashMap with concurrency level 8
ConcurrentMap&lt;String, Object&gt; map1 = new MapMaker().concurrencyLevel(8).makeMap();
</code></p>

<p>或者构造用各种不同reference作为key和value的Map：</p>

<p><code>java
//ConcurrentMap with soft reference key and weak reference value
ConcurrentMap&lt;String, Object&gt; map2 = new MapMaker().softKeys().weakValues().makeMap();
</code></p>

<p>或者构造有自动移除时间过期项的Map:</p>

<p><code>java
//Automatically removed entries from map after 30 seconds since they are created
ConcurrentMap&lt;String, Object&gt; map3 = new MapMaker().expireAfterWrite(30, TimeUnit.SECONDS).makeMap();
</code></p>

<p>或者构造有最大限制数目的Map：</p>

<p><code>java
//Map size grows close to the 100, the map vill evict
//entries that are less likely to be used again
ConcurrentMap&lt;String, Object&gt; map4 = new MapMaker().maximumSize(100).makeMap();
</code>
或者提供当Map里面不包含所get的项，而需要自动加入到Map的功能。这个功能当Map作为缓存的时候很有用：</p>

<p>```java
//Create an Object to the map, when get() is missing in map
ConcurrentMap&lt;String, Object> map5 = new MapMaker().makeComputingMap(new Function&lt;>(String, Object){</p>

<pre><code>public Object apply(String key){
    return createObject(key);
}
</code></pre>

<p>});
```</p>

<p>这些还不是最强大的特性，最厉害的是MapMaker可以提供拥有以上所有特性的Map:</p>

<p>```java
//Put all features together!
ConcurrentMap&lt;String, Object> mapAll = new MapMaker()
.concurrencyLevel(8)
.softKeys()
.weakValues()
.expireAfterWrite(30, TimeUnit.SECONDS)
.makeComputingMap(</p>

<pre><code>new Function&lt;String, Object&gt;(){
    public Object apply(String key){
        return createObject(key);
    }
}
</code></pre>

<p>);
```</p>

<h2>Ordering class:灵活的多字段排序比较器</h2>

<p>需对集合排序或者求最大值最小值，首推java.util.Collections类，但关键是要提供Comparator接口的实现。假设有个待排序的List<Foo>, 而Foo里面有两个排序关键字int a, int b和int c:</p>

<p>```java
Collections.sort(list, new Comparator<Foo>(){</p>

<pre><code>@Override
public int compare(Foo f1, Foo f2){
    int resultA = f1.a-f2.a;
    int resultB = f1.b-f2.b;
    return resultA==0?(resultB==0?fl.c-f2.c:resultB):resultA;
}
</code></pre>

<p>})
```</p>

<p>这看上去有点眼晕，如果用一串if-else也好不到哪里去。看看ComparisonChain能做到什么：</p>

<p>```java
Collections.sort*(list, new Comparator<Foo>(){</p>

<pre><code>@Override
return ComparisonChain.start()
    .compare(f1.a, f2.a)
    .compare(f1.b, f2.b)
    .compare(f1.c, f2.c).result();
</code></pre>

<p>});
```</p>

<p>如果排序关键字要用自定义比较器，compare方法也有接受Comparator的重载版本。譬如Foo里面每个排序关键字都已经有了各自的Comparator,那么利用ComparisonChain可以：</p>

<p>```java
Collections.sort(list, new Comparator<Foo>(){</p>

<pre><code>@Override
return ComparisonChain.start()
    .compare(f1.a, f2.a, comparatorA)
    .compare(f1.b, f2.b, comparatorB)
    .compare(f1.c, f2.c, comparatorC).result();
</code></pre>

<p>});
```</p>

<p>Ordring类还提供了一个组合Comparator对象的方法。而且Ordring本身实现了Comparator接口所以它能直接作为Comparator使用：</p>

<p>```java
Ordering<Foo> ordering = Ordering.compound(</p>

<pre><code>Arrays.asList(ComparatorA, comparatorB, comparatorC));
</code></pre>

<p>Collections.sort(list, ordering);
```</p>

<h2>其他特性</h2>

<h3>过滤器：利用Collection2.filter()方法过滤集合中不符合条件的元素。譬如过滤一个List<Integer>里面小于10的元素：</h3>

<p>```java
Collection<Integer> filterCollection = Collections2.filter(list, new Predicate<Integer>(){</p>

<pre><code>@Override
public boolean apply(Integer input){
    return input &gt;= 10;
}
</code></pre>

<p>});
```
当然，你可以自己写一个循环来实现这个功能，但是这样不能保证之后小于10的元素不被放入集合。filter的强大之处在于返回的filterCollection仍然有排斥小于10的元素的特性，如果调filterCollection.add(9)就会得到一个IllegalArgumentException.</p>

<h3>转换器：利用Collections.transform方法来转换集合中的元素。譬如把一个Set<Integer>里面所有元素都转化成带格式的String来产生新的Collection<String>:</h3>

<p>```java
Collection<String> formatCollection = Collection2.transform(set, new Function&lt;Integer, String>(){</p>

<pre><code>@Override
public String apply(Integer input){
    return new DecimalFormat("#,###").format(input);
}
</code></pre>

<p>})
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guava的使用指南之Basic Utilities]]></title>
    <link href="http://ajia.github.com/blog/2013/05/31/guavade-shi-yong-zhi-nan-zhi-basic-utilities/"/>
    <updated>2013-05-31T13:44:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/31/guavade-shi-yong-zhi-nan-zhi-basic-utilities</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>从避免使用null开始</h2>

<p>由于null的根本问题在于含糊而不明确，要避免使用null的方式，就是确认过去使用null的时机与目的，并使用明确的语义。在过去使用null的情况中，开发者在方法中传回null，通常代表着客户端必须检查是否为null，并在null的情况下使用预设值，以便程序能够继续执行。举个例子来说，如果原先有getNickName方法可以传回String，调用它如下：</p>

<p>```java
String nickName = getNickName("Duke");
if(nickName == null){</p>

<pre><code>nickName = "Ajia's User";
</code></pre>

<p>}
out.println(nickName);
```</p>

<p>如果客户端忘了检查null，那么就会直接显示null，在这个简单的例子中并不会怎么样，只是显示的结果令人困惑罢了，但如果后面的执行流程牵涉到至关重要的结果，程序快乐的继续执行下去，错误可能到最后才会呈现发生。</p>

<p>那么可将getNickName修改使一定传回Optional<String>(com.google.common.base)实例，但绝对不要传回null。Optional的语义是它可能包含也可能不包括值，如果你呼叫直接呼叫它的get方法：</p>

<p><code>java
String nickName = getNickName("Duke").get();
out.println(nickName);
</code></p>

<p>在Optional没有包含值的情况下，就会直接抛出IllegalStateException，这实现了速错的概念，开发者可以立即发现错误，并了解到必须作出些检查，可能的方式之一像是：</p>

<p><code>java
Optional&lt;String&gt; nick = getNickName("Duke");
String nickname = nick.isPresent()?nick.get():"CodeData User";
out.println(nickName);
</code></p>

<p>不过这看来有点啰嗦，一个比较好的方式可以是：</p>

<p><code>java
String nickName = getNickName("Duke").or("Ajia's User");
out.println(nickName);
</code></p>

<p>在getNickName方法内部，原先如果是这样传回值：</p>

<p><code>java
return rs.next()?rs.getString("nickname"):null;
</code></p>

<p>则可以使用Optional改为：</p>

<p><code>java
return rs.next()?Optional.of(rs.getString("nickname")):Optional.absent();
</code></p>

<p>Optional.of方法用来建立Optional对象包含传入的值，而Optional.absent建立的对象不包含任何值，也就是如果你直接调用后者建立的Optional对象上get方法，就会抛出异常。在有值的情况下使用Optional.of,在原本会传回null的情况下使用Optional.absent。</p>

<p>当然，过去许多程序库中使用了不少的null，这些程序无法说改就改，Guava提供了一些衔接程序库中null的方法。例如，如果原先的getNickName是你无法修改的，那么可以这么修改客户端：</p>

<p><code>java
String nickName = Optional.fromNullable(getNickName("Duke")).or("Ajia's User");
out.println(nickName);
</code></p>

<p>Optional.fromNullable在传入值为null的情况下，传回的Optional实例调用其get方法，就会抛出错误。</p>

<h3>使用Preconditions作参数的与判断</h3>

<p>Guava中提供了一个工作参数检查的工具类-Preconditions,静态导入这个类，可以大大地简化代码中对于参数的预判断和处理。</p>

<p><code>java
import static com.google.common.base.Preconditions.*;
</code></p>

<p>在以前，我们需要判断一个参数不为空需要像下面这样写：</p>

<p>```java
public void testMethod(Object obj){</p>

<pre><code>if(obj == null){
    throw new NullPointerException();
}
//... other operations
</code></pre>

<p>}
```</p>

<p>每次都要添加if语句来做判断，重复的工作会做好多次，使用Preconditions可以简化成下面这样</p>

<p>```java
public void testMethod(Object obj){</p>

<pre><code>Object other = checkNotNull(obj);
//... other operations
</code></pre>

<p>}
```</p>

<p>checkNotNull会检查参数是否为null，当为null的时候会抛出NullPointerException，否则直接返回参数。</p>

<p>checkNotNull, checkArgument和checkState，都有三种形式的参数：
* public static<T> T checkNotNull(T reference),只包含需要判断的对象，无其他多余的参数，抛出的异常不带有任何异常信息
* public static<T> T checkNotNull(T reference, @Nullable Object errorMessage),只包含一个错误信息的额外参数，抛出的异常带有errorMessage.toString()的异常信息
* public static<T> T checkNotNull(T reference, @Nullable String errorMessageTemplate, @Nullable Object…errorMessageArgs),这种是printf风格的错误信息，后面是变参，errorMessageTemplate可以使用一些占位符，例如可以这样写</p>

<p><code>java
checkArgument(i&gt;=0, "Argument was %s but expected nonnegative", i);
checkArgument(i&lt;j, "Expected i&lt;j, but %s&gt;%s", i, j);
</code></p>

<p>捕获异常后可以获取自定义的详细错误信息，对于调试来说很有帮助，而且代码也很简洁。例如，</p>

<p>```java
Object obj = null;
try{</p>

<pre><code>checkNotNull(obj, "cannot be null");
</code></pre>

<p>}catch(Exception e){</p>

<pre><code>System.out.println(e.getMessage());
</code></pre>

<p>}
```</p>

<p>运行后可以获得自定义的异常信息“cannot be null”</p>

<p>Preconditions里面的方法还有下面几个</p>

<ul>
<li>checkArgument(boolean)  检查boolean是否为真，用作方法中检查参数</li>
<li>checkNotNull(T)检查value不为null，直接返回value</li>
<li>checkState(boolean)检查对象的一些状态，不依赖方法参数。例如，Iterator可以用来next是否在remove之前被调用</li>
<li>checkElementIndex(int index, int size)检查index是否为在一个长度为size的list、string或array合法的范围。index的范围区间是[0,size)(包含0不包含size)。无需直接传入list、string或array，只需传入大小。 返回index</li>
<li>checkPositionIndex(int index, int size)检查位置index是否为在一个长度为size的list、string或array合法的范围。index的范围区间是[0, size)(包含0不包含size). 无需直接传入list, string或array, 只需传入大小</li>
<li>checkPositionIndexes(int start, int end, int size),检查[start, end)是一个长度为size的list, string或array合法的范围子集.伴随着错误信息.</li>
</ul>


<p>Guava的preconditions有这样几个有点：
* 在静态导入后，方法很明确无歧义，checkNotNull可以清楚地告诉你他是干什么的，它会抛出怎样的异常
* checkNotNull在验证通过后直接返回，可以这样方便地写代码：this.field = checkNotNull(field).
* 简单而又强大的可变参数printf风格的自定义错误信息。</p>

<p>建议将preconditions放置在单独的行上，这样可以在调试的时候清楚地指明哪个precondition出现错误。另外，提供有帮助的错误信息也非常有用。</p>

<h2>Ordering简介</h2>

<p>Ordering是Guava最常用的Comparator类，可以用来操作、扩展和使用comparators。自定义比较器，进行排序判断，进行排序，获取最大值最小值，获取最大最小的前几个值等方法。</p>

<p>几个常用的static方法，提供了三种常用的比较器</p>

<ul>
<li>natural()     使用Comparable类型的自然排序，例如，整数从小到大，字符串是按字典顺序</li>
<li>usingToString()       使用toString()返回的字符串按字典顺序进行排序</li>
</ul>


<p>使用Ordering.from(Comparator)从一个已经存在的Comparator来构建Ordering实例</p>

<p>自定义Ordering</p>

<p>```java
import java.util.Arrays;
import java.util.List;
import com.google.common.collect.Ordering;
 import com.google.common.primitives.Ints;
public class Demo {</p>

<pre><code> public static void main(String[] args) {
     Ordering&lt;String&gt; byLengthOrdering = new Ordering&lt;String&gt;() {
         public int compare(String left, String right) {
             return Ints.compare(left.length(), right.length());
         }
     };
     List&lt;String&gt; strList = Arrays.asList("abc", "a", "bcd");
</code></pre>

<p>System.out.println(byLengthOrdering.reverse().isOrdered(strList));</p>

<pre><code>     List&lt;String&gt; strList1 = Arrays.asList("a", "ab", "bcd");
     System.out.println(byLengthOrdering.isOrdered(strList1));
 }
</code></pre>

<p> }
```</p>

<p>操作方法</p>

<p>reverse()方法，获取了Ordering的反排序。使用自定义的Ordering判断collection是否符合自定义顺序。</p>

<ul>
<li>reverse()     返回与当前Ordering相反的排序</li>
<li>nullsFirst()      返回一个将null放在non-null元素之前的Ordering,其他的和原始的Ordering一样</li>
<li>compound(Comparator)返回一个使用Comparator的Ordering, Comparator作为第二排序元素，例如对bug列表进行排序，先根据bug的级别，再根据优先级进行排序。</li>
<li>lexicographical()    Returns an Ordering that orders iterables lexicographically by their elements.</li>
<li>onResultOf(Function)将function应用在各个元素上之后，再使用原始ordering进行排序。</li>
</ul>


<p>假如我们希望按sortedBy字段进行排序,
```java
class Foo {
  @Nullable String sortedBy;
  int notSortedBy;
}
Ordering<Foo> ordering = Ordering.natural().nullsFirst().onResultOf(new Function&lt;Foo, String>() {</p>

<pre><code>public String apply(Foo foo) {  
  return foo.sortedBy;  
}  
</code></pre>

<p>  });<br/>
```</p>

<p>还有一些很有用的方法
* greatestOf(Iterable iterable, int k)      Returns the k greatest elements of the specified iterable, according to this ordering, in order from greatest to least. Not necessarily stable.
* isOrdered(Iterable)       Tests if the specified Iterable is in nondecreasing order according to this ordering.
* sortedCopy(Iterable)      Returns a sorted copy of the specified elements as a List.
* min(E, E)     Returns the minimum of its two arguments according to this ordering. If the values compare as equal, the first argument is returned.
* min(E, E, E, E...)        Returns the minimum of its arguments according to this ordering. If there are multiple least values, the first is returned.
* min(Iterable)     Returns the minimum element of the specified Iterable. Throws a NoSuchElementException if the Iterable is empty.</p>

<h3>复写Object的常用方法</h3>

<p>在Java中Object类是所有类的父类，其中有几个需要override的方法比如equals,hashCode和toString等方法。每次写这几个方法都要做很多重复性的判断，很多类库提供了复写这几个方法的工具类，Guava也提供了类似的方式。下面我们来看看Guava中这几个方法简单使用。</p>

<h3>equals</h3>

<p>equals是一个经常需要覆写的方法，可以查看Object的equals方法注释，对equals有几个性质的要求：
* 1.自反性reflexive: 任何非空引用x,x.equals(x)返回为true；
* 2.对称性symmetric: 任何非空引用x和y,x.equals(y)返回true当且仅当y.equals(x)返回true；
* 传递性transitive：任何非空引用x和y，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)返回true；
* 一致性consistent：两个非空引用x和y，x.equals(y)的多次调用应该保持一致的结果，（前提条件是在多次比较之前没有修改x和y用于比较的相关信息）；
* 对于所有非null的值x，x.equals(null)都要返回false</p>

<p>当我们要覆写的类中某些值可能为null的时候，就需要对null做很多判断和分支处理。使用Guava的Object.equal方法可以避免这个问题，使得equals的方法的覆写变得更加容易，而且可读性强，简洁优雅。</p>

<p>```java
import org.junit.Test;
import com.google.common.base.Objects;
public class ObjectTest {</p>

<pre><code>@Test
public void equalTest() {
</code></pre>

<p>System.out.println(Objects.equal("a", "a"));
System.out.println(Objects.equal(null, "a"));
System.out.println(Objects.equal("a", null));
System.out.println(Objects.equal(null, null));</p>

<pre><code>}
@Test
public void equalPersonTest() {
</code></pre>

<p> System.out.println(Objects.equal(new Person("peida",23), new Person("peida",23)));</p>

<pre><code>    Person person=new Person("peida",23);
</code></pre>

<p>System.out.println(Objects.equal(person,person));</p>

<pre><code>}
</code></pre>

<p>}
class Person {</p>

<pre><code>public String name;
public int age;
Person(String name, int age) {
    this.name = name;
    this.age = age;
}
</code></pre>

<p>}
```</p>

<p>运行输出：</p>

<pre><code>true
false
false
true
false
true
</code></pre>

<h3>hashCode</h3>

<p>当覆写(override)了equals()方法之后，必须也覆写hashCode()方法，反之亦然。这个方法返回一个整型值，如果两个对象被equals()方法判断为相等，那么它们就应该拥有同样的hash code。Object类的hashCode()方法为不同的对象返回不同的值，Object类的hashCode值表示的是对象的地址。</p>

<p>hashCode的一般性契约（需要满足的条件）如下：
* 1.在Java应用的一次执行过程中，如果对象用于equals比较的信息没有被修改，那么同一个对象多次调用hashCode()方法应该返回同一个整型值。应用的多次执行中，这个值不需要保持一致，即每次执行都是保持着各自不同的值。
* 2.如果equals()判断两个对象相等，那么它们的hashCode()方法应该返回同样的值。
* 3.并没有强制要求如果equals()判断两个对象不相等，那么它们的hashCode()方法就应该返回不同的值。即，两个对象用equals()方法比较返回false，它们的hashCode可以相同也可以不同。但是，应该意识到，为两个不相等的对象产生两个不同的hashCode可以改善哈希表的性能。</p>

<p>写一个hashCode本来也不是很难，但是Guava提供给我们一个更加简单的方法--Objects.hashCode(Object …)，这是个可变参数的方法，参数列表可以是任意数量，所以可以像这样使用Object.hashCode(field1, field2, … ,fieldn)。非常方便和简洁。</p>

<p>```java
import org.junit.Test;
import com.google.common.base.Objects;
public class ObjectTest {</p>

<pre><code>@Test
public void hashcodeTest() {
</code></pre>

<p>System.out.println(Objects.hashCode("a"));
System.out.println(Objects.hashCode("a"));
System.out.println(Objects.hashCode("a","b"));
System.out.println(Objects.hashCode("b","a"));
System.out.println(Objects.hashCode("a","b","c"));
Person person=new Person("peida",23);
System.out.println(Objects.hashCode(person));
System.out.println(Objects.hashCode(person));</p>

<pre><code>}
</code></pre>

<p>}
class Person {</p>

<pre><code>public String name;
public int age;
Person(String name, int age) {
    this.name = name;
    this.age = age;
}
</code></pre>

<p>}
```</p>

<h3>toString()</h3>

<p>因为每个类都直接或间接地继承自Object,因此每个类都有toString()方法。这个方法是用得最多的，覆写得最多，一个好的toString方法对于调试来说是非常重要的，但是写起来确实很不爽。Guava也提供了toString()方法。</p>

<p>```java
import org.junit.Test;
import com.google.common.base.Objects;
public class ObjectTest {</p>

<pre><code>@Test
public void toStringTest() {
</code></pre>

<p>System.out.println(Objects.toStringHelper(this).add("x", 1).toString());
System.out.println(Objects.toStringHelper(Person.class).add("x", 1).toString());</p>

<pre><code>    Person person=new Person("peida",23);
    String result = Objects.toStringHelper(Person.class)
    .add("name", person.name)
    .add("age", person.age).toString();      
    System.out.print(result);
}
</code></pre>

<p>}
class Person {</p>

<pre><code>public String name;
public int age;
Person(String name, int age) {
    this.name = name;
    this.age = age;
}
</code></pre>

<p>}
//============输出===============
ObjectTest{x=1}
Person{x=1}
Person{name=peida, age=23}
```</p>

<h3>compare/compareTo</h3>

<p>compareTo(Object o)方法是java.lang.Comparable<T>接口中的方法，当需要对某个类的对象进行排序时，该类需要实现Comparable<T>接口的，必须重写public int compareTo(T o)方法。java规定，若a,b是两个对象，当a.compareTo(b)>0时，则a大于b，a.compareTo(b)&lt;0时，a&lt;b，即规定对象的比较大小的规则；</p>

<p>compare（Object o1, Object o2）方法是java.util.Comparator<T>接口的方法，compare方法内主要靠定义的compareTo规定的对象大小关系规则来确定对象的大小。</p>

<p>```java
import org.junit.Test;
public class ObjectTest {
@Test</p>

<pre><code>public void compareTest(){
    Person person=new Person("peida",23);
    Person person1=new Person("aida",25);
    Person person2=new Person("aida",25);
    Person person3=new Person("aida",26);
    Person person4=new Person("peida",26);
</code></pre>

<p>System.out.println(person.compareTo(person1));
System.out.println(person1.compareTo(person2));
System.out.println(person1.compareTo(person3));
System.out.println(person.compareTo(person4));
System.out.println(person4.compareTo(person));</p>

<pre><code>}
</code></pre>

<p>}
class Person implements Comparable<Person>{</p>

<pre><code>public String name;
public int age;
Person(String name, int age) {
    this.name = name;
    this.age = age;
}
@Override
public int compareTo(Person other) {
    int cmpName = name.compareTo(other.name);
    if (cmpName != 0) {
        return cmpName;
    }
    if(age&gt;other.age){
        return 1;
    }
    else if(age&lt;other.age){
        return -1;
    }
    return 0;  
}
</code></pre>

<p>}
```：</p>

<p>上面的compareTo方法，代码看上去并不是十分优雅，如果实体属性很多，数据类型丰富，代码可读性将会很差。在guava里, 对所有原始类型都提供了比较的工具函数来避免这个麻烦. 比如对Integer, 可以用Ints.compare()。利用guava的原始类型的compare，我们对上面的方法做一个简化，实现compare方法：</p>

<p>```java
class PersonComparator implements Comparator<Person> {</p>

<pre><code>@Override 
public int compare(Person p1, Person p2) {  
  int result = p1.name.compareTo(p2.name);  
  if (result != 0) {  
    return result;  
  }  
  return Ints.compare(p1.age, p2.age);  
}  
</code></pre>

<p>  }
```
上面的代码看上去简单了一点，但还是不那么优雅简单，对此, guava有一个相当聪明的解决办法, 提供了ComparisonChain:</p>

<p>```java
class Student implements Comparable<Student>{</p>

<pre><code>public String name;
public int age;
public int score;    
Student(String name, int age,int score) {
    this.name = name;
    this.age = age;
    this.score=score;
}
@Override
public int compareTo(Student other) {
    return ComparisonChain.start()
    .compare(name, other.name)
    .compare(age, other.age)
    .compare(score, other.score, Ordering.natural().nullsLast())
    .result();
}
</code></pre>

<p>}
class StudentComparator implements Comparator<Student> {</p>

<pre><code>@Override public int compare(Student s1, Student s2) {  
  return ComparisonChain.start()  
      .compare(s1.name, s2.name)  
      .compare(s1.age, s2.age)  
      .compare(s1.score, s2.score)  
      .result();  
}  
</code></pre>

<p>  }<br/>
}
```</p>

<p>ComparisonChain是一个lazy的比较过程， 当比较结果为0的时候， 即相等的时候， 会继续比较下去， 出现非0的情况， 就会忽略后面的比较。ComparisonChain实现的compare和compareTo在代码可读性和性能上都有很大的提高。</p>

<p>下面是个综合应用的实例：</p>

<p>```java
import java.util.Comparator;
import org.junit.Test;
import com.google.common.base.Objects;
import com.google.common.collect.ComparisonChain;
import com.google.common.collect.Ordering;
public class ObjectTest {
@Test
public void StudentTest(){</p>

<pre><code>    Student student=new Student("peida",23,80);
    Student student1=new Student("aida",23,36);
    Student student2=new Student("jerry",24,90);
    Student student3=new Student("peida",23,80);
    System.out.println("==========equals===========");
    System.out.println(student.equals(student2));
    System.out.println(student.equals(student1));
    System.out.println(student.equals(student3));
    System.out.println("==========hashCode===========");
    System.out.println(student.hashCode());
    System.out.println(student1.hashCode());
    System.out.println(student3.hashCode());
    System.out.println(student2.hashCode());
    System.out.println("==========toString===========");
    System.out.println(student.toString());
    System.out.println(student1.toString());
    System.out.println(student2.toString());
    System.out.println(student3.toString());
    System.out.println("==========compareTo===========");
    System.out.println(student.compareTo(student1));
    System.out.println(student.compareTo(student2));
    System.out.println(student2.compareTo(student1));
    System.out.println(student2.compareTo(student));
}
</code></pre>

<p>}
class Student implements Comparable<Student>{</p>

<pre><code>public String name;
public int age;
public int score;
Student(String name, int age,int score) {
    this.name = name;
    this.age = age;
    this.score=score;
}
@Override
public int hashCode() {
    return Objects.hashCode(name, age);
}
@Override
public boolean equals(Object obj) {
    if (obj instanceof Student) {
        Student that = (Student) obj;
        return Objects.equal(name, that.name)
                &amp;&amp; Objects.equal(age, that.age)
                &amp;&amp; Objects.equal(score, that.score);
    }
    return false;
}
@Override
public String toString() {
    return Objects.toStringHelper(this)
            .addValue(name)
            .addValue(age)
            .addValue(score)
            .toString();
}
@Override
public int compareTo(Student other) {
    return ComparisonChain.start()
    .compare(name, other.name)
    .compare(age, other.age)
    .compare(score, other.score, Ordering.natural().nullsLast())
    .result();
}
</code></pre>

<p>}
class StudentComparator implements Comparator<Student> {</p>

<pre><code>@Override public int compare(Student s1, Student s2) {  
  return ComparisonChain.start()  
      .compare(s1.name, s2.name)  
      .compare(s1.age, s2.age)  
      .compare(s1.score, s2.score)  
      .result();  
}  
</code></pre>

<p>  }<br/>
//=============运行输出===========================
==========equals===========
false
false
true
==========hashCode===========
-991998617
-991998617
-1163491205
==========toString===========
Student{peida, 23, 80}
Student{aida, 23, 36}
Student{jerry, 24, 90}
Student{peida, 23, 80}
==========compareTo===========
-1
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gson的使用指南]]></title>
    <link href="http://ajia.github.com/blog/2013/05/31/gsonde-shi-yong-zhi-nan/"/>
    <updated>2013-05-31T13:42:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/31/gsonde-shi-yong-zhi-nan</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>介绍</h1>

<p>Gson是一个可以把Java对象转化成JSON格式的字符串，也可以从一个JSON字符串转换为一个Java对象。Gson是一个开源项目，<a href="http://code.google.com/p/google-gson">这里是地址</a></p>

<h1>开始使用</h1>

<p>可以使用
<code>java
new Gson()
</code>来创建主要的类Gson的实例。也可以使用GsonBuilder来定制你需要的Gson实例，比如版本控制等等。</p>

<h3>基本的例子</h3>

<p><code>java
(Serialization)
Gson gson = new Gson();
gson.toJson(1);            ==&gt; prints 1
gson.toJson("abcd");       ==&gt; prints "abcd"
gson.toJson(new Long(10)); ==&gt; prints 10
int[] values = { 1 };
gson.toJson(values);       ==&gt; prints [1]
(Deserialization)
int one = gson.fromJson("1", int.class);
Integer one = gson.fromJson("1", Integer.class);
Long one = gson.fromJson("1", Long.class);
Boolean false = gson.fromJson("false", Boolean.class);
String str = gson.fromJson("\"abc\"", String.class);
String anotherStr = gson.fromJson("[\"abc\"]", String.class);
</code></p>

<h3>关于对象的例子</h3>

<p>```java
class BagOfPrimitives {
  private int value1 = 1;
  private String value2 = "abc";
  private transient int value3 = 3;
  BagOfPrimitives() {</p>

<pre><code>// no-args constructor
</code></pre>

<p>  }
}
(Serialization)
BagOfPrimitives obj = new BagOfPrimitives();
Gson gson = new Gson();
String json = gson.toJson(obj);<br/>
==> json is {"value1":1,"value2":"abc"}
Note that you can not serialize objects with circular references since that will result in infinite recursion.
(Deserialization)
BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class); <br/>
==> obj2 is just like obj
```<br/>
以下是转换对象的时候几点事项：
* 建议使用private的成员变量
* 没有必要对所有的成员变量使用任何的注解来表示这个变量需要被序列化或反序列化
* 如果一个成员变量被关键字transient修饰，（默认）那么它将在序列化和反序列化的时候被忽略
* 这样处理nulls是正确的
<strong> 序列化的时候，一个null变量在输出的时候将被跳过
</strong> 反序列化的时候，JSON中一个丢失的实体会被设置为null
* 如果一个成员变量被synthetic修饰，在序列化和反序列化的时候会被忽略
* 内部类、匿名类、局部类会被忽略掉。</p>

<h3>数组的例子</h3>

<p><code>java
Gson gson = new Gson();
int[] ints = {1, 2, 3, 4, 5};
String[] strings = {"abc", "def", "ghi"};
(Serialization)
gson.toJson(ints);     ==&gt; prints [1,2,3,4,5]
gson.toJson(strings);  ==&gt; prints ["abc", "def", "ghi"]
(Deserialization)
int[] ints2 = gson.fromJson("[1,2,3,4,5]", int[].class);
==&gt; ints2 will be same as ints
</code></p>

<h3>集合的例子</h3>

<p><code>java
Gson gson = new Gson();
Collection&lt;Integer&gt; ints = Lists.immutableList(1,2,3,4,5);
(Serialization)
String json = gson.toJson(ints); ==&gt; json is [1,2,3,4,5]
(Deserialization)
Type collectionType = new TypeToken&lt;Collection&lt;Integer&gt;&gt;(){}.getType();
Collection&lt;Integer&gt; ints2 = gson.fromJson(json, collectionType);
ints2 is same as ints
</code></p>

<h4>序列化和反序列化通用的类型</h4>

<p>当你在调用toJson(obj)的时候，Gson会调用obj.getClass()来获得即将被序列化的对象的成员变量。然后调用fromJson(json, MyClass.class)方法来得到MyClass的对象。如果这个类没有使用范性的情况下是正常的。但是，如果是使用范型的，由于java的类型擦除机制，就不能正常工作了。如：</p>

<p><code>java
class Foo&lt;T&gt; {
  T value;
}
Gson gson = new Gson();
Foo&lt;Bar&gt; foo = new Foo&lt;Bar&gt;();
gson.toJson(foo); // May not serialize foo.value correctly
gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[joda日期计算]]></title>
    <link href="http://ajia.github.com/blog/2013/05/24/jodari-qi-ji-suan/"/>
    <updated>2013-05-24T10:19:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/24/jodari-qi-ji-suan</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Joda-Time提供了一组Java类包用于处理包括ISO8601标准在内的date和time。可以利用它把JDK Date和Calendar类完全替换掉，而且仍然能够提供很好的集成。<a href="http://joda-time.sourceforge.net/">项目地址</a></p>

<p>获取DateTime:<br/>
<code>java
//方法一：取系统点间  
DateTime dt1 = new DateTime();  
//方法二：通过java.util.Date对象生成  
DateTime dt2 = new DateTime(new Date());  
//方法三：指定年月日点分秒生成(参数依次是：年,月,日,时,分,秒,毫秒)  
DateTime dt3 = new DateTime(2012, 5, 20, 13, 14, 0, 0);  
//方法四：ISO8601形式生成  
DateTime dt4 = new DateTime("2012-05-20");  
DateTime dt5 = new DateTime("2012-05-20T13:14:00");  
//只需要年月日的时候  
LocalDate localDate = new LocalDate(2009, 9, 6);// September 6, 2009  
//只需要时分秒毫秒的时候  
LocalTime localTime = new LocalTime(13, 30, 26, 0);// 1:30:26PM
</code></p>

<p>获取年月日点分秒<br/>
<code>java
DateTime dt = new DateTime();  
//年  
int year = dt.getYear();  
//月  
int month = dt.getMonthOfYear();  
//日  
int day = dt.getDayOfMonth();  
//星期  
int week = dt.getDayOfWeek();  
//点  
int hour = dt.getHourOfDay();  
//分  
int min = dt.getMinuteOfHour();  
//秒  
int sec = dt.getSecondOfMinute();  
//毫秒  
int msec = dt.getMillisOfSecond();
</code></p>

<p>星期的特殊处理<br/>
```java
DateTime dt = new DateTime();<br/>
//星期<br/>
switch(dt.getDayOfWeek()) {<br/>
case DateTimeConstants.SUNDAY:</p>

<pre><code>System.out.println("星期日");  
break;  
</code></pre>

<p>case DateTimeConstants.MONDAY:</p>

<pre><code>System.out.println("星期一");  
break;  
</code></pre>

<p>case DateTimeConstants.TUESDAY:</p>

<pre><code>System.out.println("星期二");  
break;  
</code></pre>

<p>case DateTimeConstants.WEDNESDAY:</p>

<pre><code>System.out.println("星期三");  
break;  
</code></pre>

<p>case DateTimeConstants.THURSDAY:</p>

<pre><code>System.out.println("星期四");  
break;  
</code></pre>

<p>case DateTimeConstants.FRIDAY:</p>

<pre><code>System.out.println("星期五");  
break;  
</code></pre>

<p>case DateTimeConstants.SATURDAY:</p>

<pre><code>System.out.println("星期六");  
break;  
</code></pre>

<p>}
```</p>

<p>与JDK日期对象转换<br/>
<code>java
DateTime dt = new DateTime();  
//转换成java.util.Date对象  
Date d1 = new Date(dt.getMillis());  
Date d2 = dt.toDate();  
//转换成java.util.Calendar对象  
Calendar c1 = Calendar.getInstance();  
c1.setTimeInMillis(dt.getMillis());  
Calendar c2 = dt.toCalendar(Locale.getDefault());
</code></p>

<p>日期前后推算<br/>
<code>java
DateTime dt = new DateTime();  
//昨天  
DateTime yesterday = dt.minusDays(1);         
//明天  
DateTime tomorrow = dt.plusDays(1);       
//1个月前  
DateTime before1month = dt.minusMonths(1);        
//3个月后  
DateTime after3month = dt.plusMonths(3);          
//2年前  
DateTime before2year = dt.minusYears(2);          
//5年后  
DateTime after5year = dt.plusYears(5);
</code></p>

<p>取特殊日期<br/>
<code>java
DateTime dt = new DateTime();     
//月末日期    
DateTime lastday = dt.dayOfMonth().withMaximumValue();  
//90天后那周的周一  
DateTime firstday = dt.plusDays(90).dayOfWeek().withMinimumValue();
</code></p>

<p>计算区间<br/>
<code>java
DateTime begin = new DateTime("2012-02-01");  
DateTime end = new DateTime("2012-05-01");  
//计算区间毫秒数  
Duration d = new Duration(begin, end);  
long time = d.getMillis();  
//计算区间天数  
Period p = new Period(begin, end, PeriodType.days());  
int days = p.getDays();  
//计算特定日期是否在该区间内  
Interval i = new Interval(begin, end);  
boolean contained = i.contains(new DateTime("2012-03-01"));
</code></p>

<p>日期比较<br/>
<code>java
DateTime d1 = new DateTime("2012-02-01");  
DateTime d2 = new DateTime("2012-05-01");  
//和系统时间比  
boolean b1 = d1.isAfterNow();  
boolean b2 = d1.isBeforeNow();  
boolean b3 = d1.isEqualNow();  
//和其他日期比  
boolean f1 = d1.isAfter(d2);  
boolean f2 = d1.isBefore(d2);  
boolean f3 = d1.isEqual(d2);
</code></p>

<p>格式化输出<br/>
<code>java
DateTime dateTime = new DateTime();  
String s1 = dateTime.toString("yyyy/MM/dd hh:mm:ss.SSSa");  
String s2 = dateTime.toString("yyyy-MM-dd HH:mm:ss");  
String s3 = dateTime.toString("EEEE dd MMMM, yyyy HH:mm:ssa");  
String s4 = dateTime.toString("yyyy/MM/dd HH:mm ZZZZ");  
String s5 = dateTime.toString("yyyy/MM/dd HH:mm Z");
</code>
时区<br/>
<code>java
//默认设置为日本时间  
DateTimeZone.setDefault(DateTimeZone.forID("Asia/Tokyo"));  
DateTime dt1 = new DateTime();  
//伦敦时间  
DateTime dt2 = new DateTime(DateTimeZone.forID("Europe/London"));
</code></p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Ajia's Blog]]></title>
  <link href="http://ajia.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://ajia.github.com/"/>
  <updated>2013-06-18T15:37:04+08:00</updated>
  <id>http://ajia.github.com/</id>
  <author>
    <name><![CDATA[Ajia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Guava的使用指南之Collections]]></title>
    <link href="http://ajia.github.com/blog/2013/05/31/guavade-shi-yong-zhi-nan-zhi-collections/"/>
    <updated>2013-05-31T13:45:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/31/guavade-shi-yong-zhi-nan-zhi-collections</id>
    <content type="html"><![CDATA[<p>Guava Collections可以帮助我们写出更简短精炼、可读性强的代码。看看Guava Collections为我们做了哪些很酷的事情：</p>

<ul>
<li>Immutable Collections:还在使用Collections.unmodifiableXXX()? Immutable Collections这才是真正的不可修改的集合</li>
<li>Multiset:看看如何把重复的元素放入一个集合</li>
<li>Multimaps:需要在一个key对应多个value的时候，自己写一个实现比较繁琐，让Multimaps来帮帮</li>
<li>BiMap:java.util.Map只能保证key的不重复，BiMap保证value也不重复</li>
<li>MapMaker:超级强大的Map构造类</li>
<li>Ordering class:大家知道用Comparator作为比较器来对集合排序，但是对于多关键字排序Ordering class可以简化很多的代码</li>
<li>其他特性</li>
</ul>


<!-- more -->


<p>当然，如果没有Guava Collections你也可以用Java Collections Framework完成上面的功能。但是Guava Collections提供的这些API经过精心设计，而且还有2500个单元测试来保障它的质量。所以我们没必要重新发明轮子。接下来我们来详细看看Guava Collections的一些具体功能。</p>

<h2>Immutable Collections：真正的不可修改的集合</h2>

<p>大家都用过Collections.unmodifiableXXX()来做一个不可修改的集合。例如你要构造存储常量的Set,你可以这样做：</p>

<p><code>java
Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(new String[]{"RED","GREEN"}));
Set&lt;String&gt; unmodifiableSet = Collections.unmodifiableSet(set);
</code></p>

<p>这看上去似乎不错，因为每次调unmodifiableSet.add()都会抛出一个UnsupportedOperationException。感觉安全了？慢！如果有人在原来的set上add或者remove元素会怎么样？结果unmodifiableSet也是被add或者remove元素了。而且构造这样一个简单的set写了两句长的代码。下面看看ImmutableSet是怎么来做地更安全和简洁：</p>

<p><code>java
ImmutableSet&lt;String&gt; immutableSet = ImmutableSet.of("RED","GREEN");
</code></p>

<p>就这样一句就够了，而且试图调add方法的时候，它一样会抛出UnsupportedOperationException。重要的是代码的可读性增强了不少，非常直观的展现了代码的用意。如果像之前这个代码保护一个set怎么做呢？你可以：</p>

<p><code>java
ImmutableSet&lt;String&gt; immutableSet = ImmutableSet.copyOf(set);
</code></p>

<p>从构造的方式来说，ImmutableSet集合还提供了Builder模式来构造一个集合：</p>

<p><code>java
Builder&lt;String&gt; builder = ImmutableSet.builder();
ImmutableSet&lt;String&gt; immutableSet = builder.add("RED").addAll(set).build();
</code></p>

<p>在这个例子里面Builder不但能加入单个元素还能加入既有的集合。</p>

<p>除此之外，Guava Collections还提供了各种Immutable集合的实现：ImmutableList, ImmutableMap, ImmutableSortedSet, ImmutableSortedMap。</p>

<h2>Multiset:把重复的元素放入集合</h2>

<p>你可能会说这和Set接口的契约冲突，因为Set接口的javaDoc里面规定不能放入重复元素。事实上，Multiset并没有实现java.util.Set接口，它更像是一个Bag。普通的Set就像这样：[car,ship,bike],而Multiset会是这样：[carx2,shipx6,bikex3]。</p>

<p>譬如一个List里面有各种字符，然后你要统计每个字符串在List里面出现的次数：</p>

<p>```java
Map&lt;String, Integer> map = new HashMap&lt;String, Integer>();
for(String word:wordList){</p>

<pre><code>Integer count = map.get(word);
map.put(word, (count==null)?1:count+1);
</code></pre>

<p>}
//count word "the"
Integer count = map.get("the");
```</p>

<p>如果用Multiset就可以这样：
<code>java
HashMultiset&lt;String&gt; multiSet = HashMultiset.create();
multiSet.addAll(wordList);
//count word "the"
Integer count = multiSet.count("the");
</code></p>

<p>这样连循环都不用了，而且Multiset用的方法叫count，显然比在Map里面调用get有更好的可读性。Multiset还提供了setCount这样设定元素重复次数的方法，虽然你可以通过使用Map来实现类似的功能，但是程序的可读性比Multiset差了很多。</p>

<p>常用实现Multiset接口的类有：
* HashMultiset:元素存放于HashMap
* LinkedHashMultiset:元素存放于LinkedHashMap,即元素的排列顺序由第一次放入的顺序决定
* TreeMultiset:元素被排序存放于TreeMap
* EnumMultiset:元素必须是enum类型
* ImmutableMultiset:不可修改的Mutiset</p>

<p>看到这里你可能已经发现Guava Collections都是以create或是of这样的静态方法来构造对象。这是因为这些集合类大多有多个参数的私有构造方法，由于参数数目很多，客户代码程序员使用起来就很不方便。而且以这种方式可以返回原类型的子类型对象。另外，对于创建范型对象来讲，这种方式更加简洁。</p>

<h2>Muitimap:在Map的value里面放多个元素</h2>

<p>Muitimap就是一个key对应多个value的数据结构。看上去它很像java.util.Map的结构，但是Muitimap不是Map，没有实现Map的接口。设想你对Map调了2次参数key一样的put方法，结果就是第2次的value覆盖了第一次的value。但是对Muitimap来说这个key同时对应了2个value。所以Map看上去是：{k1=v1,k2=v2,…}，而Muitimap是：{k1=[v1,v2,v3],k2=[v7,v8],…}。</p>

<p>举个记名投票的例子。所有选票都放在一个List<Ticket>里面，List的每个元素包括投票人和选举人的名字。我们可以这样写:</p>

<p>```java
//Key is cadidate name, its value is his voters
HashMap&lt;String, HashSet<String>> hMap = new HashMap&lt;String, HashSet<String>>();
for(Ticket ticket:tickets){</p>

<pre><code>HashSet&lt;String&gt; set = hMap.get(ticket.getCandidate());
if(set==null){
    set = new HashSet&lt;String&gt;();
    hMap.put(ticket.getCandidate(), set);
}
set.add(ticket.getVoter);
</code></pre>

<p>}
```</p>

<p>我们再来看看Muitimap能做些什么：</p>

<p>```java
HashMultimap&lt;String, String> map = HashMultimap.create();
for(Ticket ticket:tickets){</p>

<pre><code>map.put(ticket.getCandidate(), ticket.getVoter());
</code></pre>

<p>}
```</p>

<p>就这么简单！</p>

<p>Muitimap接口的主要实现类有：
* HashMultimap:key放在HashMap, 而value放在HashSet, 即一个key对应的value不可重复
* ArrayListMultimap：key放在HashMap,而value放在ArrayList,即一个key对应的value有顺序可重复
* LinkedHashMultimap:key放在LinkedHashMap,而value放在LinkedHashSet,即一个key对应的value有顺序不可重复
* TreeMultimap：key放在TreeMap，而value放在TreeSet，即一个key对应的value有排列顺序
* ImmutableMultimap:不可修改的Multimap</p>

<h2>BiMap:双向Map</h2>

<p>BiMap实现了java.util.Map接口。它的特点是它的value和它key一样也是不可重复的，换句话说它的key和value是等价的。如果你往BiMap的value里面放了重复的元素，就会得到IllegalArgumentException.</p>

<p>举个例子，你可能经常会碰到在Map里面根据value值来反推它的key值的逻辑：</p>

<p>```java
for(Map.Entry&lt;User, Address> entry:map.entreSet()){</p>

<pre><code>if(entry.getValue().equals(anAddress)){
    return entry.getKey();
}
</code></pre>

<p>}
```</p>

<p>如果把User和Address都放在BiMap,那么一句代码就得到结果了：</p>

<p>```java</p>

<pre><code>return biMap.inverse().get(anAddress);
</code></pre>

<p>```</p>

<p>这里的inverse方法就是把BiMap的key集合value集合对调，因此biMap==biMap.inverse().inverse()。</p>

<p>BiMap的常用实现有：
* HashBiMap:key集合与value集合都有HashMap实现
* EnumBiMap:key与value都必须是enum类型
* ImmutableBiMap:不可修改的BiMap</p>

<h2>MapMaker:超级强大的Map构造工具</h2>

<p>MapMaker是用来构造ConcurrentMap的工具类。为什么可以把MapMaker叫做超级强大？看了下面的例子你就知道了。首先，它可以用来构造ConcurrentHashMap:</p>

<p><code>java
//ConcurrentHashMap with concurrency level 8
ConcurrentMap&lt;String, Object&gt; map1 = new MapMaker().concurrencyLevel(8).makeMap();
</code></p>

<p>或者构造用各种不同reference作为key和value的Map：</p>

<p><code>java
//ConcurrentMap with soft reference key and weak reference value
ConcurrentMap&lt;String, Object&gt; map2 = new MapMaker().softKeys().weakValues().makeMap();
</code></p>

<p>或者构造有自动移除时间过期项的Map:</p>

<p><code>java
//Automatically removed entries from map after 30 seconds since they are created
ConcurrentMap&lt;String, Object&gt; map3 = new MapMaker().expireAfterWrite(30, TimeUnit.SECONDS).makeMap();
</code></p>

<p>或者构造有最大限制数目的Map：</p>

<p><code>java
//Map size grows close to the 100, the map vill evict
//entries that are less likely to be used again
ConcurrentMap&lt;String, Object&gt; map4 = new MapMaker().maximumSize(100).makeMap();
</code>
或者提供当Map里面不包含所get的项，而需要自动加入到Map的功能。这个功能当Map作为缓存的时候很有用：</p>

<p>```java
//Create an Object to the map, when get() is missing in map
ConcurrentMap&lt;String, Object> map5 = new MapMaker().makeComputingMap(new Function&lt;>(String, Object){</p>

<pre><code>public Object apply(String key){
    return createObject(key);
}
</code></pre>

<p>});
```</p>

<p>这些还不是最强大的特性，最厉害的是MapMaker可以提供拥有以上所有特性的Map:</p>

<p>```java
//Put all features together!
ConcurrentMap&lt;String, Object> mapAll = new MapMaker()
.concurrencyLevel(8)
.softKeys()
.weakValues()
.expireAfterWrite(30, TimeUnit.SECONDS)
.makeComputingMap(</p>

<pre><code>new Function&lt;String, Object&gt;(){
    public Object apply(String key){
        return createObject(key);
    }
}
</code></pre>

<p>);
```</p>

<h2>Ordering class:灵活的多字段排序比较器</h2>

<p>需对集合排序或者求最大值最小值，首推java.util.Collections类，但关键是要提供Comparator接口的实现。假设有个待排序的List<Foo>, 而Foo里面有两个排序关键字int a, int b和int c:</p>

<p>```java
Collections.sort(list, new Comparator<Foo>(){</p>

<pre><code>@Override
public int compare(Foo f1, Foo f2){
    int resultA = f1.a-f2.a;
    int resultB = f1.b-f2.b;
    return resultA==0?(resultB==0?fl.c-f2.c:resultB):resultA;
}
</code></pre>

<p>})
```</p>

<p>这看上去有点眼晕，如果用一串if-else也好不到哪里去。看看ComparisonChain能做到什么：</p>

<p>```java
Collections.sort*(list, new Comparator<Foo>(){</p>

<pre><code>@Override
return ComparisonChain.start()
    .compare(f1.a, f2.a)
    .compare(f1.b, f2.b)
    .compare(f1.c, f2.c).result();
</code></pre>

<p>});
```</p>

<p>如果排序关键字要用自定义比较器，compare方法也有接受Comparator的重载版本。譬如Foo里面每个排序关键字都已经有了各自的Comparator,那么利用ComparisonChain可以：</p>

<p>```java
Collections.sort(list, new Comparator<Foo>(){</p>

<pre><code>@Override
return ComparisonChain.start()
    .compare(f1.a, f2.a, comparatorA)
    .compare(f1.b, f2.b, comparatorB)
    .compare(f1.c, f2.c, comparatorC).result();
</code></pre>

<p>});
```</p>

<p>Ordring类还提供了一个组合Comparator对象的方法。而且Ordring本身实现了Comparator接口所以它能直接作为Comparator使用：</p>

<p>```java
Ordering<Foo> ordering = Ordering.compound(</p>

<pre><code>Arrays.asList(ComparatorA, comparatorB, comparatorC));
</code></pre>

<p>Collections.sort(list, ordering);
```</p>

<h2>其他特性</h2>

<h3>过滤器：利用Collection2.filter()方法过滤集合中不符合条件的元素。譬如过滤一个List<Integer>里面小于10的元素：</h3>

<p>```java
Collection<Integer> filterCollection = Collections2.filter(list, new Predicate<Integer>(){</p>

<pre><code>@Override
public boolean apply(Integer input){
    return input &gt;= 10;
}
</code></pre>

<p>});
```
当然，你可以自己写一个循环来实现这个功能，但是这样不能保证之后小于10的元素不被放入集合。filter的强大之处在于返回的filterCollection仍然有排斥小于10的元素的特性，如果调filterCollection.add(9)就会得到一个IllegalArgumentException.</p>

<h3>转换器：利用Collections.transform方法来转换集合中的元素。譬如把一个Set<Integer>里面所有元素都转化成带格式的String来产生新的Collection<String>:</h3>

<p>```java
Collection<String> formatCollection = Collection2.transform(set, new Function&lt;Integer, String>(){</p>

<pre><code>@Override
public String apply(Integer input){
    return new DecimalFormat("#,###").format(input);
}
</code></pre>

<p>})
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gson的使用指南]]></title>
    <link href="http://ajia.github.com/blog/2013/05/31/gsonde-shi-yong-zhi-nan/"/>
    <updated>2013-05-31T13:42:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/31/gsonde-shi-yong-zhi-nan</id>
    <content type="html"><![CDATA[<h1>介绍</h1>

<p>Gson是一个可以把Java对象转化成JSON格式的字符串，也可以从一个JSON字符串转换为一个Java对象。Gson是一个开源项目，<a href="http://code.google.com/p/google-gson">这里是地址</a></p>

<!-- more -->


<h1>开始使用</h1>

<p>可以使用
<code>java
new Gson()
</code>来创建主要的类Gson的实例。也可以使用GsonBuilder来定制你需要的Gson实例，比如版本控制等等。</p>

<h3>基本的例子</h3>

<p><code>java
(Serialization)
Gson gson = new Gson();
gson.toJson(1);            ==&gt; prints 1
gson.toJson("abcd");       ==&gt; prints "abcd"
gson.toJson(new Long(10)); ==&gt; prints 10
int[] values = { 1 };
gson.toJson(values);       ==&gt; prints [1]
(Deserialization)
int one = gson.fromJson("1", int.class);
Integer one = gson.fromJson("1", Integer.class);
Long one = gson.fromJson("1", Long.class);
Boolean false = gson.fromJson("false", Boolean.class);
String str = gson.fromJson("\"abc\"", String.class);
String anotherStr = gson.fromJson("[\"abc\"]", String.class);
</code></p>

<h3>关于对象的例子</h3>

<p>```java
class BagOfPrimitives {
  private int value1 = 1;
  private String value2 = "abc";
  private transient int value3 = 3;
  BagOfPrimitives() {</p>

<pre><code>// no-args constructor
</code></pre>

<p>  }
}
(Serialization)
BagOfPrimitives obj = new BagOfPrimitives();
Gson gson = new Gson();
String json = gson.toJson(obj);<br/>
==> json is {"value1":1,"value2":"abc"}
Note that you can not serialize objects with circular references since that will result in infinite recursion.
(Deserialization)
BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class); <br/>
==> obj2 is just like obj
```<br/>
以下是转换对象的时候几点事项：
* 建议使用private的成员变量
* 没有必要对所有的成员变量使用任何的注解来表示这个变量需要被序列化或反序列化
* 如果一个成员变量被关键字transient修饰，（默认）那么它将在序列化和反序列化的时候被忽略
* 这样处理nulls是正确的
<strong> 序列化的时候，一个null变量在输出的时候将被跳过
</strong> 反序列化的时候，JSON中一个丢失的实体会被设置为null
* 如果一个成员变量被synthetic修饰，在序列化和反序列化的时候会被忽略
* 内部类、匿名类、局部类会被忽略掉。</p>

<h3>数组的例子</h3>

<p><code>java
Gson gson = new Gson();
int[] ints = {1, 2, 3, 4, 5};
String[] strings = {"abc", "def", "ghi"};
(Serialization)
gson.toJson(ints);     ==&gt; prints [1,2,3,4,5]
gson.toJson(strings);  ==&gt; prints ["abc", "def", "ghi"]
(Deserialization)
int[] ints2 = gson.fromJson("[1,2,3,4,5]", int[].class);
==&gt; ints2 will be same as ints
</code></p>

<h3>集合的例子</h3>

<p><code>java
Gson gson = new Gson();
Collection&lt;Integer&gt; ints = Lists.immutableList(1,2,3,4,5);
(Serialization)
String json = gson.toJson(ints); ==&gt; json is [1,2,3,4,5]
(Deserialization)
Type collectionType = new TypeToken&lt;Collection&lt;Integer&gt;&gt;(){}.getType();
Collection&lt;Integer&gt; ints2 = gson.fromJson(json, collectionType);
ints2 is same as ints
</code></p>

<h4>序列化和反序列化通用的类型</h4>

<p>当你在调用toJson(obj)的时候，Gson会调用obj.getClass()来获得即将被序列化的对象的成员变量。然后调用fromJson(json, MyClass.class)方法来得到MyClass的对象。如果这个类没有使用范性的情况下是正常的。但是，如果是使用范型的，由于java的类型擦除机制，就不能正常工作了。如：</p>

<p><code>java
class Foo&lt;T&gt; {
  T value;
}
Gson gson = new Gson();
Foo&lt;Bar&gt; foo = new Foo&lt;Bar&gt;();
gson.toJson(foo); // May not serialize foo.value correctly
gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[joda日期计算]]></title>
    <link href="http://ajia.github.com/blog/2013/05/24/jodari-qi-ji-suan/"/>
    <updated>2013-05-24T10:19:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/24/jodari-qi-ji-suan</id>
    <content type="html"><![CDATA[<p>Joda-Time提供了一组Java类包用于处理包括ISO8601标准在内的date和time。可以利用它把JDK Date和Calendar类完全替换掉，而且仍然能够提供很好的集成。<a href="http://joda-time.sourceforge.net/">项目地址</a></p>

<!-- more -->


<p>获取DateTime:<br/>
<code>java
//方法一：取系统点间  
DateTime dt1 = new DateTime();  
//方法二：通过java.util.Date对象生成  
DateTime dt2 = new DateTime(new Date());  
//方法三：指定年月日点分秒生成(参数依次是：年,月,日,时,分,秒,毫秒)  
DateTime dt3 = new DateTime(2012, 5, 20, 13, 14, 0, 0);  
//方法四：ISO8601形式生成  
DateTime dt4 = new DateTime("2012-05-20");  
DateTime dt5 = new DateTime("2012-05-20T13:14:00");  
//只需要年月日的时候  
LocalDate localDate = new LocalDate(2009, 9, 6);// September 6, 2009  
//只需要时分秒毫秒的时候  
LocalTime localTime = new LocalTime(13, 30, 26, 0);// 1:30:26PM
</code></p>

<p>获取年月日点分秒<br/>
<code>java
DateTime dt = new DateTime();  
//年  
int year = dt.getYear();  
//月  
int month = dt.getMonthOfYear();  
//日  
int day = dt.getDayOfMonth();  
//星期  
int week = dt.getDayOfWeek();  
//点  
int hour = dt.getHourOfDay();  
//分  
int min = dt.getMinuteOfHour();  
//秒  
int sec = dt.getSecondOfMinute();  
//毫秒  
int msec = dt.getMillisOfSecond();
</code></p>

<p>星期的特殊处理<br/>
```java
DateTime dt = new DateTime();<br/>
//星期<br/>
switch(dt.getDayOfWeek()) {<br/>
case DateTimeConstants.SUNDAY:</p>

<pre><code>System.out.println("星期日");  
break;  
</code></pre>

<p>case DateTimeConstants.MONDAY:</p>

<pre><code>System.out.println("星期一");  
break;  
</code></pre>

<p>case DateTimeConstants.TUESDAY:</p>

<pre><code>System.out.println("星期二");  
break;  
</code></pre>

<p>case DateTimeConstants.WEDNESDAY:</p>

<pre><code>System.out.println("星期三");  
break;  
</code></pre>

<p>case DateTimeConstants.THURSDAY:</p>

<pre><code>System.out.println("星期四");  
break;  
</code></pre>

<p>case DateTimeConstants.FRIDAY:</p>

<pre><code>System.out.println("星期五");  
break;  
</code></pre>

<p>case DateTimeConstants.SATURDAY:</p>

<pre><code>System.out.println("星期六");  
break;  
</code></pre>

<p>}
```</p>

<p>与JDK日期对象转换<br/>
<code>java
DateTime dt = new DateTime();  
//转换成java.util.Date对象  
Date d1 = new Date(dt.getMillis());  
Date d2 = dt.toDate();  
//转换成java.util.Calendar对象  
Calendar c1 = Calendar.getInstance();  
c1.setTimeInMillis(dt.getMillis());  
Calendar c2 = dt.toCalendar(Locale.getDefault());
</code></p>

<p>日期前后推算<br/>
<code>java
DateTime dt = new DateTime();  
//昨天  
DateTime yesterday = dt.minusDays(1);         
//明天  
DateTime tomorrow = dt.plusDays(1);       
//1个月前  
DateTime before1month = dt.minusMonths(1);        
//3个月后  
DateTime after3month = dt.plusMonths(3);          
//2年前  
DateTime before2year = dt.minusYears(2);          
//5年后  
DateTime after5year = dt.plusYears(5);
</code></p>

<p>取特殊日期<br/>
<code>java
DateTime dt = new DateTime();     
//月末日期    
DateTime lastday = dt.dayOfMonth().withMaximumValue();  
//90天后那周的周一  
DateTime firstday = dt.plusDays(90).dayOfWeek().withMinimumValue();
</code></p>

<p>计算区间<br/>
<code>java
DateTime begin = new DateTime("2012-02-01");  
DateTime end = new DateTime("2012-05-01");  
//计算区间毫秒数  
Duration d = new Duration(begin, end);  
long time = d.getMillis();  
//计算区间天数  
Period p = new Period(begin, end, PeriodType.days());  
int days = p.getDays();  
//计算特定日期是否在该区间内  
Interval i = new Interval(begin, end);  
boolean contained = i.contains(new DateTime("2012-03-01"));
</code></p>

<p>日期比较<br/>
<code>java
DateTime d1 = new DateTime("2012-02-01");  
DateTime d2 = new DateTime("2012-05-01");  
//和系统时间比  
boolean b1 = d1.isAfterNow();  
boolean b2 = d1.isBeforeNow();  
boolean b3 = d1.isEqualNow();  
//和其他日期比  
boolean f1 = d1.isAfter(d2);  
boolean f2 = d1.isBefore(d2);  
boolean f3 = d1.isEqual(d2);
</code></p>

<p>格式化输出<br/>
<code>java
DateTime dateTime = new DateTime();  
String s1 = dateTime.toString("yyyy/MM/dd hh:mm:ss.SSSa");  
String s2 = dateTime.toString("yyyy-MM-dd HH:mm:ss");  
String s3 = dateTime.toString("EEEE dd MMMM, yyyy HH:mm:ssa");  
String s4 = dateTime.toString("yyyy/MM/dd HH:mm ZZZZ");  
String s5 = dateTime.toString("yyyy/MM/dd HH:mm Z");
</code>
时区<br/>
<code>java
//默认设置为日本时间  
DateTimeZone.setDefault(DateTimeZone.forID("Asia/Tokyo"));  
DateTime dt1 = new DateTime();  
//伦敦时间  
DateTime dt2 = new DateTime(DateTimeZone.forID("Europe/London"));
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读取音频文件的信息]]></title>
    <link href="http://ajia.github.com/blog/2013/05/06/du-qu-yin-pin-wen-jian-de-xin-xi/"/>
    <updated>2013-05-06T18:33:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/06/du-qu-yin-pin-wen-jian-de-xin-xi</id>
    <content type="html"><![CDATA[<p>项目里需要读取音频的播放时间，找了一个下午发现这个：jaudiotagger(http://www.jthink.net/jaudiotagger/)，它是一个音频标签JAVA库，目前支持 Mp3, Mp4 (Mp4 audio, M4a and M4p audio) Ogg Vorbis, Flac and Wma, 但是对Wav 和 Real 的支持有限。</p>

<!-- more -->


<p>读取m4a格式的播放时间<br/>
```java</p>

<pre><code>/**
 * 获取m4a格式文件的播放时间
 * @param filePath
 * @return
 */
public static int getMp4AudioLength (String filePath){
    File file = new File(filePath);
    Mp4FileReader reader = new Mp4FileReader();
    int length = -1;
    AudioFile f;
    try {
        f = reader.read(file);
        AudioHeader head = f.getAudioHeader();
        length = head.getTrackLength();
    } catch (CannotReadException e) {
        log.error(e.getMessage(), e);
    } catch (IOException e) {
        log.error(e.getMessage(), e);
    } catch (TagException e) {
        log.error(e.getMessage(), e);
    } catch (ReadOnlyFileException e) {
        log.error(e.getMessage(), e);
    } catch (InvalidAudioFrameException e) {
        log.error(e.getMessage(), e);
    }
    return length;
}
</code></pre>

<p>```</p>

<p>读取mp3格式的播放时间<br/>
```java</p>

<pre><code>/**
 * 获取mp3格式文件的播放时间
 * @param filePath
 * @return
 */
public static int getMp3AudioLength (String filePath){
    File file = new File(filePath);
    int length = -1;
    try {
        MP3File f = (MP3File)AudioFileIO.read(file);
        MP3AudioHeader audioHeader = f.getMP3AudioHeader();
        length = audioHeader.getTrackLength();
    } catch (CannotReadException e) {
        log.error(e.getMessage(), e);
    } catch (IOException e) {
        log.error(e.getMessage(), e);
    } catch (TagException e) {
        log.error(e.getMessage(), e);
    } catch (ReadOnlyFileException e) {
        log.error(e.getMessage(), e);
    } catch (InvalidAudioFrameException e) {
        log.error(e.getMessage(), e);
    }
    return length;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用jave转换音视频格式]]></title>
    <link href="http://ajia.github.com/blog/2013/05/04/shi-yong-javezhuan-huan-yin-shi-pin-ge-shi/"/>
    <updated>2013-05-04T15:54:00+08:00</updated>
    <id>http://ajia.github.com/blog/2013/05/04/shi-yong-javezhuan-huan-yin-shi-pin-ge-shi</id>
    <content type="html"><![CDATA[<p>JAVE是用java包装ffmpeg的一个类库，可以自由的在各种音视频格式之间转换，它的jar包里就包含了ffmpeg的可执行文件，有linux和windows的，我为了在本机上调试，去ffmpeg的官网下了一个Mac OSX版本的。</p>

<p>官网地址：http://www.sauronsoftware.it/projects/jave/。养成去看官网的习惯很重要，英语差点的话可以先看中文的介绍，有个概念再去看官网的说明。</p>

<!-- more -->


<p>
我是直接用源代码跑的，方便调试问题。下面是mp3转换为m4a格式的一个例子，更多的例子和请去官网查看
```java
/**</p>

<pre><code> * 转化音频格式
 * @param s
 * @param t
 * @throws IllegalArgumentException
 * @throws InputFormatException
 * @throws EncoderException
 */
private void convertAudio(String s, String t){
    File source = new File(s);
    File target = new File(t);
    AudioAttributes audio = new AudioAttributes();
    audio.setCodec("libmp3lame");
    audio.setBitRate(new Integer(128000));
    audio.setChannels(new Integer(2));
    audio.setSamplingRate(new Integer(44100));
    EncodingAttributes attrs = new EncodingAttributes();
    attrs.setFormat("mp4");
    attrs.setAudioAttributes(audio);
    Encoder encoder = new Encoder();
    try {
        encoder.encode(source, target, attrs);
    } catch (IllegalArgumentException e) {
        log.error(e.getMessage(), e);
    } catch (InputFormatException e) {
        log.error(e.getMessage(), e);
    } catch (EncoderException e) {
        log.error(e.getMessage(), e);
    }
}
</code></pre>

<p>```
转换的时候老是报错，抛出EncoderException异常，我查了一下源码，注释掉Encoder.java的864行</p>

<blockquote><blockquote><p>throw new EncoderException(line);</p></blockquote></blockquote>
]]></content>
  </entry>
  
</feed>
